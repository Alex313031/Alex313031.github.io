{"version":3,"file":"gzip-worker.js","sources":["../../node_modules/pako/dist/pako_deflate.js","../../src/js/gzip-worker/index.js"],"sourcesContent":["\n/*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.pako = {}));\n}(this, (function (exports) { 'use strict';\n\n  // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n  //\n  // This software is provided 'as-is', without any express or implied\n  // warranty. In no event will the authors be held liable for any damages\n  // arising from the use of this software.\n  //\n  // Permission is granted to anyone to use this software for any purpose,\n  // including commercial applications, and to alter it and redistribute it\n  // freely, subject to the following restrictions:\n  //\n  // 1. The origin of this software must not be misrepresented; you must not\n  //   claim that you wrote the original software. If you use this software\n  //   in a product, an acknowledgment in the product documentation would be\n  //   appreciated but is not required.\n  // 2. Altered source versions must be plainly marked as such, and must not be\n  //   misrepresented as being the original software.\n  // 3. This notice may not be removed or altered from any source distribution.\n\n  /* eslint-disable space-unary-ops */\n\n  /* Public constants ==========================================================*/\n  /* ===========================================================================*/\n\n\n  //const Z_FILTERED          = 1;\n  //const Z_HUFFMAN_ONLY      = 2;\n  //const Z_RLE               = 3;\n  const Z_FIXED$1               = 4;\n  //const Z_DEFAULT_STRATEGY  = 0;\n\n  /* Possible values of the data_type field (though see inflate()) */\n  const Z_BINARY              = 0;\n  const Z_TEXT                = 1;\n  //const Z_ASCII             = 1; // = Z_TEXT\n  const Z_UNKNOWN$1             = 2;\n\n  /*============================================================================*/\n\n\n  function zero$1(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n  // From zutil.h\n\n  const STORED_BLOCK = 0;\n  const STATIC_TREES = 1;\n  const DYN_TREES    = 2;\n  /* The three kinds of block type */\n\n  const MIN_MATCH$1    = 3;\n  const MAX_MATCH$1    = 258;\n  /* The minimum and maximum match lengths */\n\n  // From deflate.h\n  /* ===========================================================================\n   * Internal compression state.\n   */\n\n  const LENGTH_CODES$1  = 29;\n  /* number of length codes, not counting the special END_BLOCK code */\n\n  const LITERALS$1      = 256;\n  /* number of literal bytes 0..255 */\n\n  const L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;\n  /* number of Literal or Length codes, including the END_BLOCK code */\n\n  const D_CODES$1       = 30;\n  /* number of distance codes */\n\n  const BL_CODES$1      = 19;\n  /* number of codes used to transfer the bit lengths */\n\n  const HEAP_SIZE$1     = 2 * L_CODES$1 + 1;\n  /* maximum heap size */\n\n  const MAX_BITS$1      = 15;\n  /* All codes must not exceed MAX_BITS bits */\n\n  const Buf_size      = 16;\n  /* size of bit buffer in bi_buf */\n\n\n  /* ===========================================================================\n   * Constants\n   */\n\n  const MAX_BL_BITS = 7;\n  /* Bit length codes must not exceed MAX_BL_BITS bits */\n\n  const END_BLOCK   = 256;\n  /* end of block literal code */\n\n  const REP_3_6     = 16;\n  /* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\n  const REPZ_3_10   = 17;\n  /* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\n  const REPZ_11_138 = 18;\n  /* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n  /* eslint-disable comma-spacing,array-bracket-spacing */\n  const extra_lbits =   /* extra bits for each length code */\n    new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);\n\n  const extra_dbits =   /* extra bits for each distance code */\n    new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);\n\n  const extra_blbits =  /* extra bits for each bit length code */\n    new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);\n\n  const bl_order =\n    new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);\n  /* eslint-enable comma-spacing,array-bracket-spacing */\n\n  /* The lengths of the bit length codes are sent in order of decreasing\n   * probability, to avoid transmitting the lengths for unused bit length codes.\n   */\n\n  /* ===========================================================================\n   * Local data. These are initialized only once.\n   */\n\n  // We pre-fill arrays with 0 to avoid uninitialized gaps\n\n  const DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n  // !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\n  const static_ltree  = new Array((L_CODES$1 + 2) * 2);\n  zero$1(static_ltree);\n  /* The static literal tree. Since the bit lengths are imposed, there is no\n   * need for the L_CODES extra codes used during heap construction. However\n   * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n   * below).\n   */\n\n  const static_dtree  = new Array(D_CODES$1 * 2);\n  zero$1(static_dtree);\n  /* The static distance tree. (Actually a trivial tree since all codes use\n   * 5 bits.)\n   */\n\n  const _dist_code    = new Array(DIST_CODE_LEN);\n  zero$1(_dist_code);\n  /* Distance codes. The first 256 values correspond to the distances\n   * 3 .. 258, the last 256 values correspond to the top 8 bits of\n   * the 15 bit distances.\n   */\n\n  const _length_code  = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);\n  zero$1(_length_code);\n  /* length code for each normalized match length (0 == MIN_MATCH) */\n\n  const base_length   = new Array(LENGTH_CODES$1);\n  zero$1(base_length);\n  /* First normalized length for each code (0 = MIN_MATCH) */\n\n  const base_dist     = new Array(D_CODES$1);\n  zero$1(base_dist);\n  /* First normalized distance for each code (0 = distance of 1) */\n\n\n  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n    this.static_tree  = static_tree;  /* static tree or NULL */\n    this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n    this.extra_base   = extra_base;   /* base index for extra_bits */\n    this.elems        = elems;        /* max number of elements in the tree */\n    this.max_length   = max_length;   /* max bit length for the codes */\n\n    // show if `static_tree` has data or dummy - needed for monomorphic objects\n    this.has_stree    = static_tree && static_tree.length;\n  }\n\n\n  let static_l_desc;\n  let static_d_desc;\n  let static_bl_desc;\n\n\n  function TreeDesc(dyn_tree, stat_desc) {\n    this.dyn_tree = dyn_tree;     /* the dynamic tree */\n    this.max_code = 0;            /* largest code with non zero frequency */\n    this.stat_desc = stat_desc;   /* the corresponding static tree */\n  }\n\n\n\n  const d_code = (dist) => {\n\n    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n  };\n\n\n  /* ===========================================================================\n   * Output a short LSB first on the stream.\n   * IN assertion: there is enough room in pendingBuf.\n   */\n  const put_short = (s, w) => {\n  //    put_byte(s, (uch)((w) & 0xff));\n  //    put_byte(s, (uch)((ush)(w) >> 8));\n    s.pending_buf[s.pending++] = (w) & 0xff;\n    s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n  };\n\n\n  /* ===========================================================================\n   * Send a value on a given number of bits.\n   * IN assertion: length <= 16 and value fits in length bits.\n   */\n  const send_bits = (s, value, length) => {\n\n    if (s.bi_valid > (Buf_size - length)) {\n      s.bi_buf |= (value << s.bi_valid) & 0xffff;\n      put_short(s, s.bi_buf);\n      s.bi_buf = value >> (Buf_size - s.bi_valid);\n      s.bi_valid += length - Buf_size;\n    } else {\n      s.bi_buf |= (value << s.bi_valid) & 0xffff;\n      s.bi_valid += length;\n    }\n  };\n\n\n  const send_code = (s, c, tree) => {\n\n    send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n  };\n\n\n  /* ===========================================================================\n   * Reverse the first len bits of a code, using straightforward code (a faster\n   * method would use a table)\n   * IN assertion: 1 <= len <= 15\n   */\n  const bi_reverse = (code, len) => {\n\n    let res = 0;\n    do {\n      res |= code & 1;\n      code >>>= 1;\n      res <<= 1;\n    } while (--len > 0);\n    return res >>> 1;\n  };\n\n\n  /* ===========================================================================\n   * Flush the bit buffer, keeping at most 7 bits in it.\n   */\n  const bi_flush = (s) => {\n\n    if (s.bi_valid === 16) {\n      put_short(s, s.bi_buf);\n      s.bi_buf = 0;\n      s.bi_valid = 0;\n\n    } else if (s.bi_valid >= 8) {\n      s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n      s.bi_buf >>= 8;\n      s.bi_valid -= 8;\n    }\n  };\n\n\n  /* ===========================================================================\n   * Compute the optimal bit lengths for a tree and update the total bit length\n   * for the current block.\n   * IN assertion: the fields freq and dad are set, heap[heap_max] and\n   *    above are the tree nodes sorted by increasing frequency.\n   * OUT assertions: the field len is set to the optimal bit length, the\n   *     array bl_count contains the frequencies for each bit length.\n   *     The length opt_len is updated; static_len is also updated if stree is\n   *     not null.\n   */\n  const gen_bitlen = (s, desc) =>\n  //    deflate_state *s;\n  //    tree_desc *desc;    /* the tree descriptor */\n  {\n    const tree            = desc.dyn_tree;\n    const max_code        = desc.max_code;\n    const stree           = desc.stat_desc.static_tree;\n    const has_stree       = desc.stat_desc.has_stree;\n    const extra           = desc.stat_desc.extra_bits;\n    const base            = desc.stat_desc.extra_base;\n    const max_length      = desc.stat_desc.max_length;\n    let h;              /* heap index */\n    let n, m;           /* iterate over the tree elements */\n    let bits;           /* bit length */\n    let xbits;          /* extra bits */\n    let f;              /* frequency */\n    let overflow = 0;   /* number of elements with bit length too large */\n\n    for (bits = 0; bits <= MAX_BITS$1; bits++) {\n      s.bl_count[bits] = 0;\n    }\n\n    /* In a first pass, compute the optimal bit lengths (which may\n     * overflow in the case of the bit length tree).\n     */\n    tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n    for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {\n      n = s.heap[h];\n      bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n      if (bits > max_length) {\n        bits = max_length;\n        overflow++;\n      }\n      tree[n * 2 + 1]/*.Len*/ = bits;\n      /* We overwrite tree[n].Dad which is no longer needed */\n\n      if (n > max_code) { continue; } /* not a leaf node */\n\n      s.bl_count[bits]++;\n      xbits = 0;\n      if (n >= base) {\n        xbits = extra[n - base];\n      }\n      f = tree[n * 2]/*.Freq*/;\n      s.opt_len += f * (bits + xbits);\n      if (has_stree) {\n        s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n      }\n    }\n    if (overflow === 0) { return; }\n\n    // Trace((stderr,\"\\nbit length overflow\\n\"));\n    /* This happens for example on obj2 and pic of the Calgary corpus */\n\n    /* Find the first bit length which could increase: */\n    do {\n      bits = max_length - 1;\n      while (s.bl_count[bits] === 0) { bits--; }\n      s.bl_count[bits]--;      /* move one leaf down the tree */\n      s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n      s.bl_count[max_length]--;\n      /* The brother of the overflow item also moves one step up,\n       * but this does not affect bl_count[max_length]\n       */\n      overflow -= 2;\n    } while (overflow > 0);\n\n    /* Now recompute all bit lengths, scanning in increasing frequency.\n     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n     * lengths instead of fixing only the wrong ones. This idea is taken\n     * from 'ar' written by Haruhiko Okumura.)\n     */\n    for (bits = max_length; bits !== 0; bits--) {\n      n = s.bl_count[bits];\n      while (n !== 0) {\n        m = s.heap[--h];\n        if (m > max_code) { continue; }\n        if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n          // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n          s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n          tree[m * 2 + 1]/*.Len*/ = bits;\n        }\n        n--;\n      }\n    }\n  };\n\n\n  /* ===========================================================================\n   * Generate the codes for a given tree and bit counts (which need not be\n   * optimal).\n   * IN assertion: the array bl_count contains the bit length statistics for\n   * the given tree and the field len is set for all tree elements.\n   * OUT assertion: the field code is set for all tree elements of non\n   *     zero code length.\n   */\n  const gen_codes = (tree, max_code, bl_count) =>\n  //    ct_data *tree;             /* the tree to decorate */\n  //    int max_code;              /* largest code with non zero frequency */\n  //    ushf *bl_count;            /* number of codes at each bit length */\n  {\n    const next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */\n    let code = 0;              /* running code value */\n    let bits;                  /* bit index */\n    let n;                     /* code index */\n\n    /* The distribution counts are first used to generate the code values\n     * without bit reversal.\n     */\n    for (bits = 1; bits <= MAX_BITS$1; bits++) {\n      next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n    }\n    /* Check that the bit counts in bl_count are consistent. The last code\n     * must be all ones.\n     */\n    //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n    //        \"inconsistent bit counts\");\n    //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n    for (n = 0;  n <= max_code; n++) {\n      let len = tree[n * 2 + 1]/*.Len*/;\n      if (len === 0) { continue; }\n      /* Now reverse the bits */\n      tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n      //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n      //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n    }\n  };\n\n\n  /* ===========================================================================\n   * Initialize the various 'constant' tables.\n   */\n  const tr_static_init = () => {\n\n    let n;        /* iterates over tree elements */\n    let bits;     /* bit counter */\n    let length;   /* length value */\n    let code;     /* code value */\n    let dist;     /* distance index */\n    const bl_count = new Array(MAX_BITS$1 + 1);\n    /* number of codes at each bit length for an optimal tree */\n\n    // do check in _tr_init()\n    //if (static_init_done) return;\n\n    /* For some embedded targets, global variables are not initialized: */\n  /*#ifdef NO_INIT_GLOBAL_POINTERS\n    static_l_desc.static_tree = static_ltree;\n    static_l_desc.extra_bits = extra_lbits;\n    static_d_desc.static_tree = static_dtree;\n    static_d_desc.extra_bits = extra_dbits;\n    static_bl_desc.extra_bits = extra_blbits;\n  #endif*/\n\n    /* Initialize the mapping length (0..255) -> length code (0..28) */\n    length = 0;\n    for (code = 0; code < LENGTH_CODES$1 - 1; code++) {\n      base_length[code] = length;\n      for (n = 0; n < (1 << extra_lbits[code]); n++) {\n        _length_code[length++] = code;\n      }\n    }\n    //Assert (length == 256, \"tr_static_init: length != 256\");\n    /* Note that the length 255 (match length 258) can be represented\n     * in two different ways: code 284 + 5 bits or code 285, so we\n     * overwrite length_code[255] to use the best encoding:\n     */\n    _length_code[length - 1] = code;\n\n    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n    dist = 0;\n    for (code = 0; code < 16; code++) {\n      base_dist[code] = dist;\n      for (n = 0; n < (1 << extra_dbits[code]); n++) {\n        _dist_code[dist++] = code;\n      }\n    }\n    //Assert (dist == 256, \"tr_static_init: dist != 256\");\n    dist >>= 7; /* from now on, all distances are divided by 128 */\n    for (; code < D_CODES$1; code++) {\n      base_dist[code] = dist << 7;\n      for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n        _dist_code[256 + dist++] = code;\n      }\n    }\n    //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n    /* Construct the codes of the static literal tree */\n    for (bits = 0; bits <= MAX_BITS$1; bits++) {\n      bl_count[bits] = 0;\n    }\n\n    n = 0;\n    while (n <= 143) {\n      static_ltree[n * 2 + 1]/*.Len*/ = 8;\n      n++;\n      bl_count[8]++;\n    }\n    while (n <= 255) {\n      static_ltree[n * 2 + 1]/*.Len*/ = 9;\n      n++;\n      bl_count[9]++;\n    }\n    while (n <= 279) {\n      static_ltree[n * 2 + 1]/*.Len*/ = 7;\n      n++;\n      bl_count[7]++;\n    }\n    while (n <= 287) {\n      static_ltree[n * 2 + 1]/*.Len*/ = 8;\n      n++;\n      bl_count[8]++;\n    }\n    /* Codes 286 and 287 do not exist, but we must include them in the\n     * tree construction to get a canonical Huffman tree (longest code\n     * all ones)\n     */\n    gen_codes(static_ltree, L_CODES$1 + 1, bl_count);\n\n    /* The static distance tree is trivial: */\n    for (n = 0; n < D_CODES$1; n++) {\n      static_dtree[n * 2 + 1]/*.Len*/ = 5;\n      static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n    }\n\n    // Now data ready and we can init static trees\n    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);\n    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES$1, MAX_BITS$1);\n    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES$1, MAX_BL_BITS);\n\n    //static_init_done = true;\n  };\n\n\n  /* ===========================================================================\n   * Initialize a new block.\n   */\n  const init_block = (s) => {\n\n    let n; /* iterates over tree elements */\n\n    /* Initialize the trees. */\n    for (n = 0; n < L_CODES$1;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n    for (n = 0; n < D_CODES$1;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n    for (n = 0; n < BL_CODES$1; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n    s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n    s.opt_len = s.static_len = 0;\n    s.last_lit = s.matches = 0;\n  };\n\n\n  /* ===========================================================================\n   * Flush the bit buffer and align the output on a byte boundary\n   */\n  const bi_windup = (s) =>\n  {\n    if (s.bi_valid > 8) {\n      put_short(s, s.bi_buf);\n    } else if (s.bi_valid > 0) {\n      //put_byte(s, (Byte)s->bi_buf);\n      s.pending_buf[s.pending++] = s.bi_buf;\n    }\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n  };\n\n  /* ===========================================================================\n   * Copy a stored block, storing first the length and its\n   * one's complement if requested.\n   */\n  const copy_block = (s, buf, len, header) =>\n  //DeflateState *s;\n  //charf    *buf;    /* the input data */\n  //unsigned len;     /* its length */\n  //int      header;  /* true if block header must be written */\n  {\n    bi_windup(s);        /* align on byte boundary */\n\n    if (header) {\n      put_short(s, len);\n      put_short(s, ~len);\n    }\n  //  while (len--) {\n  //    put_byte(s, *buf++);\n  //  }\n    s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);\n    s.pending += len;\n  };\n\n  /* ===========================================================================\n   * Compares to subtrees, using the tree depth as tie breaker when\n   * the subtrees have equal frequency. This minimizes the worst case length.\n   */\n  const smaller = (tree, n, m, depth) => {\n\n    const _n2 = n * 2;\n    const _m2 = m * 2;\n    return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n           (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n  };\n\n  /* ===========================================================================\n   * Restore the heap property by moving down the tree starting at node k,\n   * exchanging a node with the smallest of its two sons if necessary, stopping\n   * when the heap property is re-established (each father smaller than its\n   * two sons).\n   */\n  const pqdownheap = (s, tree, k) =>\n  //    deflate_state *s;\n  //    ct_data *tree;  /* the tree to restore */\n  //    int k;               /* node to move down */\n  {\n    const v = s.heap[k];\n    let j = k << 1;  /* left son of k */\n    while (j <= s.heap_len) {\n      /* Set j to the smallest of the two sons: */\n      if (j < s.heap_len &&\n        smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n        j++;\n      }\n      /* Exit if v is smaller than both sons */\n      if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n      /* Exchange v with the smallest son */\n      s.heap[k] = s.heap[j];\n      k = j;\n\n      /* And continue down the tree, setting j to the left son of k */\n      j <<= 1;\n    }\n    s.heap[k] = v;\n  };\n\n\n  // inlined manually\n  // const SMALLEST = 1;\n\n  /* ===========================================================================\n   * Send the block data compressed using the given Huffman trees\n   */\n  const compress_block = (s, ltree, dtree) =>\n  //    deflate_state *s;\n  //    const ct_data *ltree; /* literal tree */\n  //    const ct_data *dtree; /* distance tree */\n  {\n    let dist;           /* distance of matched string */\n    let lc;             /* match length or unmatched char (if dist == 0) */\n    let lx = 0;         /* running index in l_buf */\n    let code;           /* the code to send */\n    let extra;          /* number of extra bits to send */\n\n    if (s.last_lit !== 0) {\n      do {\n        dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n        lc = s.pending_buf[s.l_buf + lx];\n        lx++;\n\n        if (dist === 0) {\n          send_code(s, lc, ltree); /* send a literal byte */\n          //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n        } else {\n          /* Here, lc is the match length - MIN_MATCH */\n          code = _length_code[lc];\n          send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */\n          extra = extra_lbits[code];\n          if (extra !== 0) {\n            lc -= base_length[code];\n            send_bits(s, lc, extra);       /* send the extra length bits */\n          }\n          dist--; /* dist is now the match distance - 1 */\n          code = d_code(dist);\n          //Assert (code < D_CODES, \"bad d_code\");\n\n          send_code(s, code, dtree);       /* send the distance code */\n          extra = extra_dbits[code];\n          if (extra !== 0) {\n            dist -= base_dist[code];\n            send_bits(s, dist, extra);   /* send the extra distance bits */\n          }\n        } /* literal or match pair ? */\n\n        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n        //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n        //       \"pendingBuf overflow\");\n\n      } while (lx < s.last_lit);\n    }\n\n    send_code(s, END_BLOCK, ltree);\n  };\n\n\n  /* ===========================================================================\n   * Construct one Huffman tree and assigns the code bit strings and lengths.\n   * Update the total bit length for the current block.\n   * IN assertion: the field freq is set for all tree elements.\n   * OUT assertions: the fields len and code are set to the optimal bit length\n   *     and corresponding code. The length opt_len is updated; static_len is\n   *     also updated if stree is not null. The field max_code is set.\n   */\n  const build_tree = (s, desc) =>\n  //    deflate_state *s;\n  //    tree_desc *desc; /* the tree descriptor */\n  {\n    const tree     = desc.dyn_tree;\n    const stree    = desc.stat_desc.static_tree;\n    const has_stree = desc.stat_desc.has_stree;\n    const elems    = desc.stat_desc.elems;\n    let n, m;          /* iterate over heap elements */\n    let max_code = -1; /* largest code with non zero frequency */\n    let node;          /* new node being created */\n\n    /* Construct the initial heap, with least frequent element in\n     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n     * heap[0] is not used.\n     */\n    s.heap_len = 0;\n    s.heap_max = HEAP_SIZE$1;\n\n    for (n = 0; n < elems; n++) {\n      if (tree[n * 2]/*.Freq*/ !== 0) {\n        s.heap[++s.heap_len] = max_code = n;\n        s.depth[n] = 0;\n\n      } else {\n        tree[n * 2 + 1]/*.Len*/ = 0;\n      }\n    }\n\n    /* The pkzip format requires that at least one distance code exists,\n     * and that at least one bit should be sent even if there is only one\n     * possible code. So to avoid special checks later on we force at least\n     * two codes of non zero frequency.\n     */\n    while (s.heap_len < 2) {\n      node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n      tree[node * 2]/*.Freq*/ = 1;\n      s.depth[node] = 0;\n      s.opt_len--;\n\n      if (has_stree) {\n        s.static_len -= stree[node * 2 + 1]/*.Len*/;\n      }\n      /* node is 0 or 1 so it does not have extra bits */\n    }\n    desc.max_code = max_code;\n\n    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n     * establish sub-heaps of increasing lengths:\n     */\n    for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n    /* Construct the Huffman tree by repeatedly combining the least two\n     * frequent nodes.\n     */\n    node = elems;              /* next internal node of the tree */\n    do {\n      //pqremove(s, tree, n);  /* n = node of least frequency */\n      /*** pqremove ***/\n      n = s.heap[1/*SMALLEST*/];\n      s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n      pqdownheap(s, tree, 1/*SMALLEST*/);\n      /***/\n\n      m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n      s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n      s.heap[--s.heap_max] = m;\n\n      /* Create a new node father of n and m */\n      tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n      tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n      /* and insert the new node in the heap */\n      s.heap[1/*SMALLEST*/] = node++;\n      pqdownheap(s, tree, 1/*SMALLEST*/);\n\n    } while (s.heap_len >= 2);\n\n    s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n    /* At this point, the fields freq and dad are set. We can now\n     * generate the bit lengths.\n     */\n    gen_bitlen(s, desc);\n\n    /* The field len is now set, we can generate the bit codes */\n    gen_codes(tree, max_code, s.bl_count);\n  };\n\n\n  /* ===========================================================================\n   * Scan a literal or distance tree to determine the frequencies of the codes\n   * in the bit length tree.\n   */\n  const scan_tree = (s, tree, max_code) =>\n  //    deflate_state *s;\n  //    ct_data *tree;   /* the tree to be scanned */\n  //    int max_code;    /* and its largest code of non zero frequency */\n  {\n    let n;                     /* iterates over all tree elements */\n    let prevlen = -1;          /* last emitted length */\n    let curlen;                /* length of current code */\n\n    let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n    let count = 0;             /* repeat count of the current code */\n    let max_count = 7;         /* max repeat count */\n    let min_count = 4;         /* min repeat count */\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n    }\n    tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n    for (n = 0; n <= max_code; n++) {\n      curlen = nextlen;\n      nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n      if (++count < max_count && curlen === nextlen) {\n        continue;\n\n      } else if (count < min_count) {\n        s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n      } else if (curlen !== 0) {\n\n        if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n        s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n      } else if (count <= 10) {\n        s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n      } else {\n        s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n      }\n\n      count = 0;\n      prevlen = curlen;\n\n      if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n\n      } else if (curlen === nextlen) {\n        max_count = 6;\n        min_count = 3;\n\n      } else {\n        max_count = 7;\n        min_count = 4;\n      }\n    }\n  };\n\n\n  /* ===========================================================================\n   * Send a literal or distance tree in compressed form, using the codes in\n   * bl_tree.\n   */\n  const send_tree = (s, tree, max_code) =>\n  //    deflate_state *s;\n  //    ct_data *tree; /* the tree to be scanned */\n  //    int max_code;       /* and its largest code of non zero frequency */\n  {\n    let n;                     /* iterates over all tree elements */\n    let prevlen = -1;          /* last emitted length */\n    let curlen;                /* length of current code */\n\n    let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n    let count = 0;             /* repeat count of the current code */\n    let max_count = 7;         /* max repeat count */\n    let min_count = 4;         /* min repeat count */\n\n    /* tree[max_code+1].Len = -1; */  /* guard already set */\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n    }\n\n    for (n = 0; n <= max_code; n++) {\n      curlen = nextlen;\n      nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n      if (++count < max_count && curlen === nextlen) {\n        continue;\n\n      } else if (count < min_count) {\n        do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n      } else if (curlen !== 0) {\n        if (curlen !== prevlen) {\n          send_code(s, curlen, s.bl_tree);\n          count--;\n        }\n        //Assert(count >= 3 && count <= 6, \" 3_6?\");\n        send_code(s, REP_3_6, s.bl_tree);\n        send_bits(s, count - 3, 2);\n\n      } else if (count <= 10) {\n        send_code(s, REPZ_3_10, s.bl_tree);\n        send_bits(s, count - 3, 3);\n\n      } else {\n        send_code(s, REPZ_11_138, s.bl_tree);\n        send_bits(s, count - 11, 7);\n      }\n\n      count = 0;\n      prevlen = curlen;\n      if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n\n      } else if (curlen === nextlen) {\n        max_count = 6;\n        min_count = 3;\n\n      } else {\n        max_count = 7;\n        min_count = 4;\n      }\n    }\n  };\n\n\n  /* ===========================================================================\n   * Construct the Huffman tree for the bit lengths and return the index in\n   * bl_order of the last bit length code to send.\n   */\n  const build_bl_tree = (s) => {\n\n    let max_blindex;  /* index of last bit length code of non zero freq */\n\n    /* Determine the bit length frequencies for literal and distance trees */\n    scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n    /* Build the bit length tree: */\n    build_tree(s, s.bl_desc);\n    /* opt_len now includes the length of the tree representations, except\n     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n     */\n\n    /* Determine the number of bit length codes to send. The pkzip format\n     * requires that at least 4 bit length codes be sent. (appnote.txt says\n     * 3 but the actual value used is 4.)\n     */\n    for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {\n      if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n        break;\n      }\n    }\n    /* Update opt_len to include the bit length tree and counts */\n    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n    //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n    //        s->opt_len, s->static_len));\n\n    return max_blindex;\n  };\n\n\n  /* ===========================================================================\n   * Send the header for a block using dynamic Huffman trees: the counts, the\n   * lengths of the bit length codes, the literal tree and the distance tree.\n   * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n   */\n  const send_all_trees = (s, lcodes, dcodes, blcodes) =>\n  //    deflate_state *s;\n  //    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n  {\n    let rank;                    /* index in bl_order */\n\n    //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n    //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n    //        \"too many codes\");\n    //Tracev((stderr, \"\\nbl counts: \"));\n    send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n    send_bits(s, dcodes - 1,   5);\n    send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n    for (rank = 0; rank < blcodes; rank++) {\n      //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n      send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n    }\n    //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n    send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n    //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n    send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n    //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n  };\n\n\n  /* ===========================================================================\n   * Check if the data type is TEXT or BINARY, using the following algorithm:\n   * - TEXT if the two conditions below are satisfied:\n   *    a) There are no non-portable control characters belonging to the\n   *       \"black list\" (0..6, 14..25, 28..31).\n   *    b) There is at least one printable character belonging to the\n   *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n   * - BINARY otherwise.\n   * - The following partially-portable control characters form a\n   *   \"gray list\" that is ignored in this detection algorithm:\n   *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n   * IN assertion: the fields Freq of dyn_ltree are set.\n   */\n  const detect_data_type = (s) => {\n    /* black_mask is the bit mask of black-listed bytes\n     * set bits 0..6, 14..25, and 28..31\n     * 0xf3ffc07f = binary 11110011111111111100000001111111\n     */\n    let black_mask = 0xf3ffc07f;\n    let n;\n\n    /* Check for non-textual (\"black-listed\") bytes. */\n    for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n      if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n        return Z_BINARY;\n      }\n    }\n\n    /* Check for textual (\"white-listed\") bytes. */\n    if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n        s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n    for (n = 32; n < LITERALS$1; n++) {\n      if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n        return Z_TEXT;\n      }\n    }\n\n    /* There are no \"black-listed\" or \"white-listed\" bytes:\n     * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n     */\n    return Z_BINARY;\n  };\n\n\n  let static_init_done = false;\n\n  /* ===========================================================================\n   * Initialize the tree data structures for a new zlib stream.\n   */\n  const _tr_init$1 = (s) =>\n  {\n\n    if (!static_init_done) {\n      tr_static_init();\n      static_init_done = true;\n    }\n\n    s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n    s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n    /* Initialize the first block of the first file: */\n    init_block(s);\n  };\n\n\n  /* ===========================================================================\n   * Send a stored block\n   */\n  const _tr_stored_block$1 = (s, buf, stored_len, last) =>\n  //DeflateState *s;\n  //charf *buf;       /* input block */\n  //ulg stored_len;   /* length of input block */\n  //int last;         /* one if this is the last block for a file */\n  {\n    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n    copy_block(s, buf, stored_len, true); /* with header */\n  };\n\n\n  /* ===========================================================================\n   * Send one empty static block to give enough lookahead for inflate.\n   * This takes 10 bits, of which 7 may remain in the bit buffer.\n   */\n  const _tr_align$1 = (s) => {\n    send_bits(s, STATIC_TREES << 1, 3);\n    send_code(s, END_BLOCK, static_ltree);\n    bi_flush(s);\n  };\n\n\n  /* ===========================================================================\n   * Determine the best encoding for the current block: dynamic trees, static\n   * trees or store, and output the encoded block to the zip file.\n   */\n  const _tr_flush_block$1 = (s, buf, stored_len, last) =>\n  //DeflateState *s;\n  //charf *buf;       /* input block, or NULL if too old */\n  //ulg stored_len;   /* length of input block */\n  //int last;         /* one if this is the last block for a file */\n  {\n    let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n    let max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n    /* Build the Huffman trees unless a stored block is forced */\n    if (s.level > 0) {\n\n      /* Check if the file is binary or text */\n      if (s.strm.data_type === Z_UNKNOWN$1) {\n        s.strm.data_type = detect_data_type(s);\n      }\n\n      /* Construct the literal and distance trees */\n      build_tree(s, s.l_desc);\n      // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n      //        s->static_len));\n\n      build_tree(s, s.d_desc);\n      // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n      //        s->static_len));\n      /* At this point, opt_len and static_len are the total bit lengths of\n       * the compressed block data, excluding the tree representations.\n       */\n\n      /* Build the bit length tree for the above two trees, and get the index\n       * in bl_order of the last bit length code to send.\n       */\n      max_blindex = build_bl_tree(s);\n\n      /* Determine the best encoding. Compute the block lengths in bytes. */\n      opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n      static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n      // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n      //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n      //        s->last_lit));\n\n      if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n    } else {\n      // Assert(buf != (char*)0, \"lost buf\");\n      opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n    }\n\n    if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n      /* 4: two words for the lengths */\n\n      /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n       * Otherwise we can't have processed more than WSIZE input bytes since\n       * the last block flush, because compression would have been\n       * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n       * transform a block into a stored block.\n       */\n      _tr_stored_block$1(s, buf, stored_len, last);\n\n    } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {\n\n      send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n      compress_block(s, static_ltree, static_dtree);\n\n    } else {\n      send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n      send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n      compress_block(s, s.dyn_ltree, s.dyn_dtree);\n    }\n    // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n    /* The above check is made mod 2^32, for files larger than 512 MB\n     * and uLong implemented on 32 bits.\n     */\n    init_block(s);\n\n    if (last) {\n      bi_windup(s);\n    }\n    // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n    //       s->compressed_len-7*last));\n  };\n\n  /* ===========================================================================\n   * Save the match info and tally the frequency counts. Return true if\n   * the current block must be flushed.\n   */\n  const _tr_tally$1 = (s, dist, lc) =>\n  //    deflate_state *s;\n  //    unsigned dist;  /* distance of matched string */\n  //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n  {\n    //let out_length, in_length, dcode;\n\n    s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n    s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n    s.last_lit++;\n\n    if (dist === 0) {\n      /* lc is the unmatched char */\n      s.dyn_ltree[lc * 2]/*.Freq*/++;\n    } else {\n      s.matches++;\n      /* Here, lc is the match length - MIN_MATCH */\n      dist--;             /* dist = match distance - 1 */\n      //Assert((ush)dist < (ush)MAX_DIST(s) &&\n      //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n      //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n      s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]/*.Freq*/++;\n      s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n    }\n\n  // (!) This block is disabled in zlib defaults,\n  // don't enable it for binary compatibility\n\n  //#ifdef TRUNCATE_BLOCK\n  //  /* Try to guess if it is profitable to stop the current block here */\n  //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n  //    /* Compute an upper bound for the compressed length */\n  //    out_length = s.last_lit*8;\n  //    in_length = s.strstart - s.block_start;\n  //\n  //    for (dcode = 0; dcode < D_CODES; dcode++) {\n  //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n  //    }\n  //    out_length >>>= 3;\n  //    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n  //    //       s->last_lit, in_length, out_length,\n  //    //       100L - out_length*100L/in_length));\n  //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n  //      return true;\n  //    }\n  //  }\n  //#endif\n\n    return (s.last_lit === s.lit_bufsize - 1);\n    /* We avoid equality with lit_bufsize because of wraparound at 64K\n     * on 16 bit machines and because stored blocks are restricted to\n     * 64K-1 bytes.\n     */\n  };\n\n  var _tr_init_1  = _tr_init$1;\n  var _tr_stored_block_1 = _tr_stored_block$1;\n  var _tr_flush_block_1  = _tr_flush_block$1;\n  var _tr_tally_1 = _tr_tally$1;\n  var _tr_align_1 = _tr_align$1;\n\n  var trees = {\n  \t_tr_init: _tr_init_1,\n  \t_tr_stored_block: _tr_stored_block_1,\n  \t_tr_flush_block: _tr_flush_block_1,\n  \t_tr_tally: _tr_tally_1,\n  \t_tr_align: _tr_align_1\n  };\n\n  // Note: adler32 takes 12% for level 0 and 2% for level 6.\n  // It isn't worth it to make additional optimizations as in original.\n  // Small size is preferable.\n\n  // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n  //\n  // This software is provided 'as-is', without any express or implied\n  // warranty. In no event will the authors be held liable for any damages\n  // arising from the use of this software.\n  //\n  // Permission is granted to anyone to use this software for any purpose,\n  // including commercial applications, and to alter it and redistribute it\n  // freely, subject to the following restrictions:\n  //\n  // 1. The origin of this software must not be misrepresented; you must not\n  //   claim that you wrote the original software. If you use this software\n  //   in a product, an acknowledgment in the product documentation would be\n  //   appreciated but is not required.\n  // 2. Altered source versions must be plainly marked as such, and must not be\n  //   misrepresented as being the original software.\n  // 3. This notice may not be removed or altered from any source distribution.\n\n  const adler32 = (adler, buf, len, pos) => {\n    let s1 = (adler & 0xffff) |0,\n        s2 = ((adler >>> 16) & 0xffff) |0,\n        n = 0;\n\n    while (len !== 0) {\n      // Set limit ~ twice less than 5552, to keep\n      // s2 in 31-bits, because we force signed ints.\n      // in other case %= will fail.\n      n = len > 2000 ? 2000 : len;\n      len -= n;\n\n      do {\n        s1 = (s1 + buf[pos++]) |0;\n        s2 = (s2 + s1) |0;\n      } while (--n);\n\n      s1 %= 65521;\n      s2 %= 65521;\n    }\n\n    return (s1 | (s2 << 16)) |0;\n  };\n\n\n  var adler32_1 = adler32;\n\n  // Note: we can't get significant speed boost here.\n  // So write code to minimize size - no pregenerated tables\n  // and array tools dependencies.\n\n  // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n  //\n  // This software is provided 'as-is', without any express or implied\n  // warranty. In no event will the authors be held liable for any damages\n  // arising from the use of this software.\n  //\n  // Permission is granted to anyone to use this software for any purpose,\n  // including commercial applications, and to alter it and redistribute it\n  // freely, subject to the following restrictions:\n  //\n  // 1. The origin of this software must not be misrepresented; you must not\n  //   claim that you wrote the original software. If you use this software\n  //   in a product, an acknowledgment in the product documentation would be\n  //   appreciated but is not required.\n  // 2. Altered source versions must be plainly marked as such, and must not be\n  //   misrepresented as being the original software.\n  // 3. This notice may not be removed or altered from any source distribution.\n\n  // Use ordinary array, since untyped makes no boost here\n  const makeTable = () => {\n    let c, table = [];\n\n    for (var n = 0; n < 256; n++) {\n      c = n;\n      for (var k = 0; k < 8; k++) {\n        c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n      }\n      table[n] = c;\n    }\n\n    return table;\n  };\n\n  // Create table on load. Just 255 signed longs. Not a problem.\n  const crcTable = new Uint32Array(makeTable());\n\n\n  const crc32 = (crc, buf, len, pos) => {\n    const t = crcTable;\n    const end = pos + len;\n\n    crc ^= -1;\n\n    for (let i = pos; i < end; i++) {\n      crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n    }\n\n    return (crc ^ (-1)); // >>> 0;\n  };\n\n\n  var crc32_1 = crc32;\n\n  // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n  //\n  // This software is provided 'as-is', without any express or implied\n  // warranty. In no event will the authors be held liable for any damages\n  // arising from the use of this software.\n  //\n  // Permission is granted to anyone to use this software for any purpose,\n  // including commercial applications, and to alter it and redistribute it\n  // freely, subject to the following restrictions:\n  //\n  // 1. The origin of this software must not be misrepresented; you must not\n  //   claim that you wrote the original software. If you use this software\n  //   in a product, an acknowledgment in the product documentation would be\n  //   appreciated but is not required.\n  // 2. Altered source versions must be plainly marked as such, and must not be\n  //   misrepresented as being the original software.\n  // 3. This notice may not be removed or altered from any source distribution.\n\n  var messages = {\n    2:      'need dictionary',     /* Z_NEED_DICT       2  */\n    1:      'stream end',          /* Z_STREAM_END      1  */\n    0:      '',                    /* Z_OK              0  */\n    '-1':   'file error',          /* Z_ERRNO         (-1) */\n    '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n    '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n    '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n    '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n    '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n  };\n\n  // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n  //\n  // This software is provided 'as-is', without any express or implied\n  // warranty. In no event will the authors be held liable for any damages\n  // arising from the use of this software.\n  //\n  // Permission is granted to anyone to use this software for any purpose,\n  // including commercial applications, and to alter it and redistribute it\n  // freely, subject to the following restrictions:\n  //\n  // 1. The origin of this software must not be misrepresented; you must not\n  //   claim that you wrote the original software. If you use this software\n  //   in a product, an acknowledgment in the product documentation would be\n  //   appreciated but is not required.\n  // 2. Altered source versions must be plainly marked as such, and must not be\n  //   misrepresented as being the original software.\n  // 3. This notice may not be removed or altered from any source distribution.\n\n  var constants$1 = {\n\n    /* Allowed flush values; see deflate() and inflate() below for details */\n    Z_NO_FLUSH:         0,\n    Z_PARTIAL_FLUSH:    1,\n    Z_SYNC_FLUSH:       2,\n    Z_FULL_FLUSH:       3,\n    Z_FINISH:           4,\n    Z_BLOCK:            5,\n    Z_TREES:            6,\n\n    /* Return codes for the compression/decompression functions. Negative values\n    * are errors, positive values are used for special but normal events.\n    */\n    Z_OK:               0,\n    Z_STREAM_END:       1,\n    Z_NEED_DICT:        2,\n    Z_ERRNO:           -1,\n    Z_STREAM_ERROR:    -2,\n    Z_DATA_ERROR:      -3,\n    Z_MEM_ERROR:       -4,\n    Z_BUF_ERROR:       -5,\n    //Z_VERSION_ERROR: -6,\n\n    /* compression levels */\n    Z_NO_COMPRESSION:         0,\n    Z_BEST_SPEED:             1,\n    Z_BEST_COMPRESSION:       9,\n    Z_DEFAULT_COMPRESSION:   -1,\n\n\n    Z_FILTERED:               1,\n    Z_HUFFMAN_ONLY:           2,\n    Z_RLE:                    3,\n    Z_FIXED:                  4,\n    Z_DEFAULT_STRATEGY:       0,\n\n    /* Possible values of the data_type field (though see inflate()) */\n    Z_BINARY:                 0,\n    Z_TEXT:                   1,\n    //Z_ASCII:                1, // = Z_TEXT (deprecated)\n    Z_UNKNOWN:                2,\n\n    /* The deflate compression method */\n    Z_DEFLATED:               8\n    //Z_NULL:                 null // Use -1 or null inline, depending on var type\n  };\n\n  // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n  //\n  // This software is provided 'as-is', without any express or implied\n  // warranty. In no event will the authors be held liable for any damages\n  // arising from the use of this software.\n  //\n  // Permission is granted to anyone to use this software for any purpose,\n  // including commercial applications, and to alter it and redistribute it\n  // freely, subject to the following restrictions:\n  //\n  // 1. The origin of this software must not be misrepresented; you must not\n  //   claim that you wrote the original software. If you use this software\n  //   in a product, an acknowledgment in the product documentation would be\n  //   appreciated but is not required.\n  // 2. Altered source versions must be plainly marked as such, and must not be\n  //   misrepresented as being the original software.\n  // 3. This notice may not be removed or altered from any source distribution.\n\n  const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;\n\n\n\n\n  /* Public constants ==========================================================*/\n  /* ===========================================================================*/\n\n  const {\n    Z_NO_FLUSH: Z_NO_FLUSH$1, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$1, Z_BLOCK,\n    Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_STREAM_ERROR, Z_DATA_ERROR, Z_BUF_ERROR,\n    Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,\n    Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,\n    Z_UNKNOWN,\n    Z_DEFLATED: Z_DEFLATED$1\n  } = constants$1;\n\n  /*============================================================================*/\n\n\n  const MAX_MEM_LEVEL = 9;\n  /* Maximum value for memLevel in deflateInit2 */\n  const MAX_WBITS = 15;\n  /* 32K LZ77 window */\n  const DEF_MEM_LEVEL = 8;\n\n\n  const LENGTH_CODES  = 29;\n  /* number of length codes, not counting the special END_BLOCK code */\n  const LITERALS      = 256;\n  /* number of literal bytes 0..255 */\n  const L_CODES       = LITERALS + 1 + LENGTH_CODES;\n  /* number of Literal or Length codes, including the END_BLOCK code */\n  const D_CODES       = 30;\n  /* number of distance codes */\n  const BL_CODES      = 19;\n  /* number of codes used to transfer the bit lengths */\n  const HEAP_SIZE     = 2 * L_CODES + 1;\n  /* maximum heap size */\n  const MAX_BITS  = 15;\n  /* All codes must not exceed MAX_BITS bits */\n\n  const MIN_MATCH = 3;\n  const MAX_MATCH = 258;\n  const MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\n  const PRESET_DICT = 0x20;\n\n  const INIT_STATE = 42;\n  const EXTRA_STATE = 69;\n  const NAME_STATE = 73;\n  const COMMENT_STATE = 91;\n  const HCRC_STATE = 103;\n  const BUSY_STATE = 113;\n  const FINISH_STATE = 666;\n\n  const BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\n  const BS_BLOCK_DONE     = 2; /* block flush performed */\n  const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\n  const BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\n  const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\n  const err = (strm, errorCode) => {\n    strm.msg = messages[errorCode];\n    return errorCode;\n  };\n\n  const rank = (f) => {\n    return ((f) << 1) - ((f) > 4 ? 9 : 0);\n  };\n\n  const zero = (buf) => {\n    let len = buf.length; while (--len >= 0) { buf[len] = 0; }\n  };\n\n\n  /* eslint-disable new-cap */\n  let HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;\n  // This hash causes less collisions, https://github.com/nodeca/pako/issues/135\n  // But breaks binary compatibility\n  //let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;\n  let HASH = HASH_ZLIB;\n\n  /* =========================================================================\n   * Flush as much pending output as possible. All deflate() output goes\n   * through this function so some applications may wish to modify it\n   * to avoid allocating a large strm->output buffer and copying into it.\n   * (See also read_buf()).\n   */\n  const flush_pending = (strm) => {\n    const s = strm.state;\n\n    //_tr_flush_bits(s);\n    let len = s.pending;\n    if (len > strm.avail_out) {\n      len = strm.avail_out;\n    }\n    if (len === 0) { return; }\n\n    strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);\n    strm.next_out += len;\n    s.pending_out += len;\n    strm.total_out += len;\n    strm.avail_out -= len;\n    s.pending -= len;\n    if (s.pending === 0) {\n      s.pending_out = 0;\n    }\n  };\n\n\n  const flush_block_only = (s, last) => {\n    _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n    s.block_start = s.strstart;\n    flush_pending(s.strm);\n  };\n\n\n  const put_byte = (s, b) => {\n    s.pending_buf[s.pending++] = b;\n  };\n\n\n  /* =========================================================================\n   * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n   * IN assertion: the stream state is correct and there is enough room in\n   * pending_buf.\n   */\n  const putShortMSB = (s, b) => {\n\n    //  put_byte(s, (Byte)(b >> 8));\n  //  put_byte(s, (Byte)(b & 0xff));\n    s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n    s.pending_buf[s.pending++] = b & 0xff;\n  };\n\n\n  /* ===========================================================================\n   * Read a new buffer from the current input stream, update the adler32\n   * and total number of bytes read.  All deflate() input goes through\n   * this function so some applications may wish to modify it to avoid\n   * allocating a large strm->input buffer and copying from it.\n   * (See also flush_pending()).\n   */\n  const read_buf = (strm, buf, start, size) => {\n\n    let len = strm.avail_in;\n\n    if (len > size) { len = size; }\n    if (len === 0) { return 0; }\n\n    strm.avail_in -= len;\n\n    // zmemcpy(buf, strm->next_in, len);\n    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);\n    if (strm.state.wrap === 1) {\n      strm.adler = adler32_1(strm.adler, buf, len, start);\n    }\n\n    else if (strm.state.wrap === 2) {\n      strm.adler = crc32_1(strm.adler, buf, len, start);\n    }\n\n    strm.next_in += len;\n    strm.total_in += len;\n\n    return len;\n  };\n\n\n  /* ===========================================================================\n   * Set match_start to the longest match starting at the given string and\n   * return its length. Matches shorter or equal to prev_length are discarded,\n   * in which case the result is equal to prev_length and match_start is\n   * garbage.\n   * IN assertions: cur_match is the head of the hash chain for the current\n   *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n   * OUT assertion: the match length is not greater than s->lookahead.\n   */\n  const longest_match = (s, cur_match) => {\n\n    let chain_length = s.max_chain_length;      /* max hash chain length */\n    let scan = s.strstart; /* current string */\n    let match;                       /* matched string */\n    let len;                           /* length of current match */\n    let best_len = s.prev_length;              /* best match length so far */\n    let nice_match = s.nice_match;             /* stop if match long enough */\n    const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n        s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n    const _win = s.window; // shortcut\n\n    const wmask = s.w_mask;\n    const prev  = s.prev;\n\n    /* Stop when cur_match becomes <= limit. To simplify the code,\n     * we prevent matches with the string of window index 0.\n     */\n\n    const strend = s.strstart + MAX_MATCH;\n    let scan_end1  = _win[scan + best_len - 1];\n    let scan_end   = _win[scan + best_len];\n\n    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n     * It is easy to get rid of this optimization if necessary.\n     */\n    // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n    /* Do not waste too much time if we already have a good match: */\n    if (s.prev_length >= s.good_match) {\n      chain_length >>= 2;\n    }\n    /* Do not look for matches beyond the end of the input. This is necessary\n     * to make deflate deterministic.\n     */\n    if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n    // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n    do {\n      // Assert(cur_match < s->strstart, \"no future\");\n      match = cur_match;\n\n      /* Skip to next match if the match length cannot increase\n       * or if the match length is less than 2.  Note that the checks below\n       * for insufficient lookahead only occur occasionally for performance\n       * reasons.  Therefore uninitialized memory will be accessed, and\n       * conditional jumps will be made that depend on those values.\n       * However the length of the match is limited to the lookahead, so\n       * the output of deflate is not affected by the uninitialized values.\n       */\n\n      if (_win[match + best_len]     !== scan_end  ||\n          _win[match + best_len - 1] !== scan_end1 ||\n          _win[match]                !== _win[scan] ||\n          _win[++match]              !== _win[scan + 1]) {\n        continue;\n      }\n\n      /* The check at best_len-1 can be removed because it will be made\n       * again later. (This heuristic is not always a win.)\n       * It is not necessary to compare scan[2] and match[2] since they\n       * are always equal when the other bytes match, given that\n       * the hash keys are equal and that HASH_BITS >= 8.\n       */\n      scan += 2;\n      match++;\n      // Assert(*scan == *match, \"match[2]?\");\n\n      /* We check for insufficient lookahead only every 8th comparison;\n       * the 256th check will be made at strstart+258.\n       */\n      do {\n        /*jshint noempty:false*/\n      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n               _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n               _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n               _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n               scan < strend);\n\n      // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n      len = MAX_MATCH - (strend - scan);\n      scan = strend - MAX_MATCH;\n\n      if (len > best_len) {\n        s.match_start = cur_match;\n        best_len = len;\n        if (len >= nice_match) {\n          break;\n        }\n        scan_end1  = _win[scan + best_len - 1];\n        scan_end   = _win[scan + best_len];\n      }\n    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n    if (best_len <= s.lookahead) {\n      return best_len;\n    }\n    return s.lookahead;\n  };\n\n\n  /* ===========================================================================\n   * Fill the window when the lookahead becomes insufficient.\n   * Updates strstart and lookahead.\n   *\n   * IN assertion: lookahead < MIN_LOOKAHEAD\n   * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n   *    At least one byte has been read, or avail_in == 0; reads are\n   *    performed for at least two bytes (required for the zip translate_eol\n   *    option -- not supported here).\n   */\n  const fill_window = (s) => {\n\n    const _w_size = s.w_size;\n    let p, n, m, more, str;\n\n    //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n    do {\n      more = s.window_size - s.lookahead - s.strstart;\n\n      // JS ints have 32 bit, block below not needed\n      /* Deal with !@#$% 64K limit: */\n      //if (sizeof(int) <= 2) {\n      //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n      //        more = wsize;\n      //\n      //  } else if (more == (unsigned)(-1)) {\n      //        /* Very unlikely, but possible on 16 bit machine if\n      //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n      //         */\n      //        more--;\n      //    }\n      //}\n\n\n      /* If the window is almost full and there is insufficient lookahead,\n       * move the upper half to the lower one to make room in the upper half.\n       */\n      if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n        s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);\n        s.match_start -= _w_size;\n        s.strstart -= _w_size;\n        /* we now have strstart >= MAX_DIST */\n        s.block_start -= _w_size;\n\n        /* Slide the hash table (could be avoided with 32 bit values\n         at the expense of memory usage). We slide even when level == 0\n         to keep the hash table consistent if we switch back to level > 0\n         later. (Using level 0 permanently is not an optimal usage of\n         zlib, so we don't care about this pathological case.)\n         */\n\n        n = s.hash_size;\n        p = n;\n\n        do {\n          m = s.head[--p];\n          s.head[p] = (m >= _w_size ? m - _w_size : 0);\n        } while (--n);\n\n        n = _w_size;\n        p = n;\n\n        do {\n          m = s.prev[--p];\n          s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n          /* If n is not on any hash chain, prev[n] is garbage but\n           * its value will never be used.\n           */\n        } while (--n);\n\n        more += _w_size;\n      }\n      if (s.strm.avail_in === 0) {\n        break;\n      }\n\n      /* If there was no sliding:\n       *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n       *    more == window_size - lookahead - strstart\n       * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n       * => more >= window_size - 2*WSIZE + 2\n       * In the BIG_MEM or MMAP case (not yet supported),\n       *   window_size == input_size + MIN_LOOKAHEAD  &&\n       *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n       * Otherwise, window_size == 2*WSIZE so more >= 2.\n       * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n       */\n      //Assert(more >= 2, \"more < 2\");\n      n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n      s.lookahead += n;\n\n      /* Initialize the hash value now that we have some input: */\n      if (s.lookahead + s.insert >= MIN_MATCH) {\n        str = s.strstart - s.insert;\n        s.ins_h = s.window[str];\n\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);\n  //#if MIN_MATCH != 3\n  //        Call update_hash() MIN_MATCH-3 more times\n  //#endif\n        while (s.insert) {\n          /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n          s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n          s.prev[str & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = str;\n          str++;\n          s.insert--;\n          if (s.lookahead + s.insert < MIN_MATCH) {\n            break;\n          }\n        }\n      }\n      /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n       * but this is not important since only literal bytes will be emitted.\n       */\n\n    } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n    /* If the WIN_INIT bytes after the end of the current data have never been\n     * written, then zero those bytes in order to avoid memory check reports of\n     * the use of uninitialized (or uninitialised as Julian writes) bytes by\n     * the longest match routines.  Update the high water mark for the next\n     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n     */\n  //  if (s.high_water < s.window_size) {\n  //    const curr = s.strstart + s.lookahead;\n  //    let init = 0;\n  //\n  //    if (s.high_water < curr) {\n  //      /* Previous high water mark below current data -- zero WIN_INIT\n  //       * bytes or up to end of window, whichever is less.\n  //       */\n  //      init = s.window_size - curr;\n  //      if (init > WIN_INIT)\n  //        init = WIN_INIT;\n  //      zmemzero(s->window + curr, (unsigned)init);\n  //      s->high_water = curr + init;\n  //    }\n  //    else if (s->high_water < (ulg)curr + WIN_INIT) {\n  //      /* High water mark at or above current data, but below current data\n  //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n  //       * to end of window, whichever is less.\n  //       */\n  //      init = (ulg)curr + WIN_INIT - s->high_water;\n  //      if (init > s->window_size - s->high_water)\n  //        init = s->window_size - s->high_water;\n  //      zmemzero(s->window + s->high_water, (unsigned)init);\n  //      s->high_water += init;\n  //    }\n  //  }\n  //\n  //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n  //    \"not enough room for search\");\n  };\n\n  /* ===========================================================================\n   * Copy without compression as much as possible from the input stream, return\n   * the current block state.\n   * This function does not insert new strings in the dictionary since\n   * uncompressible data is probably not useful. This function is used\n   * only for the level=0 compression option.\n   * NOTE: this function should be optimized to avoid extra copying from\n   * window to pending_buf.\n   */\n  const deflate_stored = (s, flush) => {\n\n    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n     * to pending_buf_size, and each stored block has a 5 byte header:\n     */\n    let max_block_size = 0xffff;\n\n    if (max_block_size > s.pending_buf_size - 5) {\n      max_block_size = s.pending_buf_size - 5;\n    }\n\n    /* Copy as much as possible from input to output: */\n    for (;;) {\n      /* Fill the window as much as possible: */\n      if (s.lookahead <= 1) {\n\n        //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n        //  s->block_start >= (long)s->w_size, \"slide too late\");\n  //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n  //        s.block_start >= s.w_size)) {\n  //        throw  new Error(\"slide too late\");\n  //      }\n\n        fill_window(s);\n        if (s.lookahead === 0 && flush === Z_NO_FLUSH$1) {\n          return BS_NEED_MORE;\n        }\n\n        if (s.lookahead === 0) {\n          break;\n        }\n        /* flush the current block */\n      }\n      //Assert(s->block_start >= 0L, \"block gone\");\n  //    if (s.block_start < 0) throw new Error(\"block gone\");\n\n      s.strstart += s.lookahead;\n      s.lookahead = 0;\n\n      /* Emit a stored block if pending_buf will be full: */\n      const max_start = s.block_start + max_block_size;\n\n      if (s.strstart === 0 || s.strstart >= max_start) {\n        /* strstart == 0 is possible when wraparound on 16-bit machine */\n        s.lookahead = s.strstart - max_start;\n        s.strstart = max_start;\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n\n\n      }\n      /* Flush if we may have to slide, otherwise block_start may become\n       * negative and the data will be gone:\n       */\n      if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n    }\n\n    s.insert = 0;\n\n    if (flush === Z_FINISH$1) {\n      /*** FLUSH_BLOCK(s, 1); ***/\n      flush_block_only(s, true);\n      if (s.strm.avail_out === 0) {\n        return BS_FINISH_STARTED;\n      }\n      /***/\n      return BS_FINISH_DONE;\n    }\n\n    if (s.strstart > s.block_start) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n\n    return BS_NEED_MORE;\n  };\n\n  /* ===========================================================================\n   * Compress as much as possible from the input stream, return the current\n   * block state.\n   * This function does not perform lazy evaluation of matches and inserts\n   * new strings in the dictionary only for unmatched strings or for short\n   * matches. It is used only for the fast compression options.\n   */\n  const deflate_fast = (s, flush) => {\n\n    let hash_head;        /* head of the hash chain */\n    let bflush;           /* set if current block must be flushed */\n\n    for (;;) {\n      /* Make sure that we always have enough lookahead, except\n       * at the end of the input file. We need MAX_MATCH bytes\n       * for the next match, plus MIN_MATCH bytes to insert the\n       * string following the next match.\n       */\n      if (s.lookahead < MIN_LOOKAHEAD) {\n        fill_window(s);\n        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$1) {\n          return BS_NEED_MORE;\n        }\n        if (s.lookahead === 0) {\n          break; /* flush the current block */\n        }\n      }\n\n      /* Insert the string window[strstart .. strstart+2] in the\n       * dictionary, and set hash_head to the head of the hash chain:\n       */\n      hash_head = 0/*NIL*/;\n      if (s.lookahead >= MIN_MATCH) {\n        /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = s.strstart;\n        /***/\n      }\n\n      /* Find the longest match, discarding those <= prev_length.\n       * At this point we have always match_length < MIN_MATCH\n       */\n      if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n        /* To simplify the code, we prevent matches with the string\n         * of window index 0 (in particular we have to avoid a match\n         * of the string with itself at the start of the input file).\n         */\n        s.match_length = longest_match(s, hash_head);\n        /* longest_match() sets match_start */\n      }\n      if (s.match_length >= MIN_MATCH) {\n        // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n        /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                       s.match_length - MIN_MATCH, bflush); ***/\n        bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n        s.lookahead -= s.match_length;\n\n        /* Insert new strings in the hash table only if the match length\n         * is not too large. This saves time but degrades compression.\n         */\n        if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n          s.match_length--; /* string at strstart already in table */\n          do {\n            s.strstart++;\n            /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = s.strstart;\n            /***/\n            /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n             * always MIN_MATCH bytes ahead.\n             */\n          } while (--s.match_length !== 0);\n          s.strstart++;\n        } else\n        {\n          s.strstart += s.match_length;\n          s.match_length = 0;\n          s.ins_h = s.window[s.strstart];\n          /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);\n\n  //#if MIN_MATCH != 3\n  //                Call UPDATE_HASH() MIN_MATCH-3 more times\n  //#endif\n          /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n           * matter since it will be recomputed at next deflate call.\n           */\n        }\n      } else {\n        /* No match, output a literal byte */\n        //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n        /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n        bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n        s.lookahead--;\n        s.strstart++;\n      }\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n    }\n    s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n    if (flush === Z_FINISH$1) {\n      /*** FLUSH_BLOCK(s, 1); ***/\n      flush_block_only(s, true);\n      if (s.strm.avail_out === 0) {\n        return BS_FINISH_STARTED;\n      }\n      /***/\n      return BS_FINISH_DONE;\n    }\n    if (s.last_lit) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n    return BS_BLOCK_DONE;\n  };\n\n  /* ===========================================================================\n   * Same as above, but achieves better compression. We use a lazy\n   * evaluation for matches: a match is finally adopted only if there is\n   * no better match at the next window position.\n   */\n  const deflate_slow = (s, flush) => {\n\n    let hash_head;          /* head of hash chain */\n    let bflush;              /* set if current block must be flushed */\n\n    let max_insert;\n\n    /* Process the input block. */\n    for (;;) {\n      /* Make sure that we always have enough lookahead, except\n       * at the end of the input file. We need MAX_MATCH bytes\n       * for the next match, plus MIN_MATCH bytes to insert the\n       * string following the next match.\n       */\n      if (s.lookahead < MIN_LOOKAHEAD) {\n        fill_window(s);\n        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$1) {\n          return BS_NEED_MORE;\n        }\n        if (s.lookahead === 0) { break; } /* flush the current block */\n      }\n\n      /* Insert the string window[strstart .. strstart+2] in the\n       * dictionary, and set hash_head to the head of the hash chain:\n       */\n      hash_head = 0/*NIL*/;\n      if (s.lookahead >= MIN_MATCH) {\n        /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = s.strstart;\n        /***/\n      }\n\n      /* Find the longest match, discarding those <= prev_length.\n       */\n      s.prev_length = s.match_length;\n      s.prev_match = s.match_start;\n      s.match_length = MIN_MATCH - 1;\n\n      if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n          s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n        /* To simplify the code, we prevent matches with the string\n         * of window index 0 (in particular we have to avoid a match\n         * of the string with itself at the start of the input file).\n         */\n        s.match_length = longest_match(s, hash_head);\n        /* longest_match() sets match_start */\n\n        if (s.match_length <= 5 &&\n           (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n          /* If prev_match is also MIN_MATCH, match_start is garbage\n           * but we will ignore the current match anyway.\n           */\n          s.match_length = MIN_MATCH - 1;\n        }\n      }\n      /* If there was a match at the previous step and the current\n       * match is not better, output the previous match:\n       */\n      if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n        max_insert = s.strstart + s.lookahead - MIN_MATCH;\n        /* Do not insert strings in hash table beyond this. */\n\n        //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n        /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                       s.prev_length - MIN_MATCH, bflush);***/\n        bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n        /* Insert in hash table all strings up to the end of the match.\n         * strstart-1 and strstart are already inserted. If there is not\n         * enough lookahead, the last two strings are not inserted in\n         * the hash table.\n         */\n        s.lookahead -= s.prev_length - 1;\n        s.prev_length -= 2;\n        do {\n          if (++s.strstart <= max_insert) {\n            /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = s.strstart;\n            /***/\n          }\n        } while (--s.prev_length !== 0);\n        s.match_available = 0;\n        s.match_length = MIN_MATCH - 1;\n        s.strstart++;\n\n        if (bflush) {\n          /*** FLUSH_BLOCK(s, 0); ***/\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n        }\n\n      } else if (s.match_available) {\n        /* If there was no match at the previous position, output a\n         * single literal. If there was a match but the current match\n         * is longer, truncate the previous match to a single literal.\n         */\n        //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n        /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n        bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n        if (bflush) {\n          /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n          flush_block_only(s, false);\n          /***/\n        }\n        s.strstart++;\n        s.lookahead--;\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n      } else {\n        /* There is no previous match to compare with, wait for\n         * the next step to decide.\n         */\n        s.match_available = 1;\n        s.strstart++;\n        s.lookahead--;\n      }\n    }\n    //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n    if (s.match_available) {\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      s.match_available = 0;\n    }\n    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n    if (flush === Z_FINISH$1) {\n      /*** FLUSH_BLOCK(s, 1); ***/\n      flush_block_only(s, true);\n      if (s.strm.avail_out === 0) {\n        return BS_FINISH_STARTED;\n      }\n      /***/\n      return BS_FINISH_DONE;\n    }\n    if (s.last_lit) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n\n    return BS_BLOCK_DONE;\n  };\n\n\n  /* ===========================================================================\n   * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n   * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n   * deflate switches away from Z_RLE.)\n   */\n  const deflate_rle = (s, flush) => {\n\n    let bflush;            /* set if current block must be flushed */\n    let prev;              /* byte at distance one to match */\n    let scan, strend;      /* scan goes up to strend for length of run */\n\n    const _win = s.window;\n\n    for (;;) {\n      /* Make sure that we always have enough lookahead, except\n       * at the end of the input file. We need MAX_MATCH bytes\n       * for the longest run, plus one for the unrolled loop.\n       */\n      if (s.lookahead <= MAX_MATCH) {\n        fill_window(s);\n        if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$1) {\n          return BS_NEED_MORE;\n        }\n        if (s.lookahead === 0) { break; } /* flush the current block */\n      }\n\n      /* See how many times the previous byte repeats */\n      s.match_length = 0;\n      if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n        scan = s.strstart - 1;\n        prev = _win[scan];\n        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n          strend = s.strstart + MAX_MATCH;\n          do {\n            /*jshint noempty:false*/\n          } while (prev === _win[++scan] && prev === _win[++scan] &&\n                   prev === _win[++scan] && prev === _win[++scan] &&\n                   prev === _win[++scan] && prev === _win[++scan] &&\n                   prev === _win[++scan] && prev === _win[++scan] &&\n                   scan < strend);\n          s.match_length = MAX_MATCH - (strend - scan);\n          if (s.match_length > s.lookahead) {\n            s.match_length = s.lookahead;\n          }\n        }\n        //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n      }\n\n      /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n      if (s.match_length >= MIN_MATCH) {\n        //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n        /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n        bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n        s.lookahead -= s.match_length;\n        s.strstart += s.match_length;\n        s.match_length = 0;\n      } else {\n        /* No match, output a literal byte */\n        //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n        /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n        bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n        s.lookahead--;\n        s.strstart++;\n      }\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n    }\n    s.insert = 0;\n    if (flush === Z_FINISH$1) {\n      /*** FLUSH_BLOCK(s, 1); ***/\n      flush_block_only(s, true);\n      if (s.strm.avail_out === 0) {\n        return BS_FINISH_STARTED;\n      }\n      /***/\n      return BS_FINISH_DONE;\n    }\n    if (s.last_lit) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n    return BS_BLOCK_DONE;\n  };\n\n  /* ===========================================================================\n   * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n   * (It will be regenerated if this run of deflate switches away from Huffman.)\n   */\n  const deflate_huff = (s, flush) => {\n\n    let bflush;             /* set if current block must be flushed */\n\n    for (;;) {\n      /* Make sure that we have a literal to write. */\n      if (s.lookahead === 0) {\n        fill_window(s);\n        if (s.lookahead === 0) {\n          if (flush === Z_NO_FLUSH$1) {\n            return BS_NEED_MORE;\n          }\n          break;      /* flush the current block */\n        }\n      }\n\n      /* Output a literal byte */\n      s.match_length = 0;\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n      s.lookahead--;\n      s.strstart++;\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n    }\n    s.insert = 0;\n    if (flush === Z_FINISH$1) {\n      /*** FLUSH_BLOCK(s, 1); ***/\n      flush_block_only(s, true);\n      if (s.strm.avail_out === 0) {\n        return BS_FINISH_STARTED;\n      }\n      /***/\n      return BS_FINISH_DONE;\n    }\n    if (s.last_lit) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n    return BS_BLOCK_DONE;\n  };\n\n  /* Values for max_lazy_match, good_match and max_chain_length, depending on\n   * the desired pack level (0..9). The values given below have been tuned to\n   * exclude worst case performance for pathological files. Better values may be\n   * found for specific files.\n   */\n  function Config(good_length, max_lazy, nice_length, max_chain, func) {\n\n    this.good_length = good_length;\n    this.max_lazy = max_lazy;\n    this.nice_length = nice_length;\n    this.max_chain = max_chain;\n    this.func = func;\n  }\n\n  const configuration_table = [\n    /*      good lazy nice chain */\n    new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n    new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n    new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n    new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n    new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n    new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n    new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n    new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n    new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n    new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n  ];\n\n\n  /* ===========================================================================\n   * Initialize the \"longest match\" routines for a new zlib stream\n   */\n  const lm_init = (s) => {\n\n    s.window_size = 2 * s.w_size;\n\n    /*** CLEAR_HASH(s); ***/\n    zero(s.head); // Fill with NIL (= 0);\n\n    /* Set the default configuration parameters:\n     */\n    s.max_lazy_match = configuration_table[s.level].max_lazy;\n    s.good_match = configuration_table[s.level].good_length;\n    s.nice_match = configuration_table[s.level].nice_length;\n    s.max_chain_length = configuration_table[s.level].max_chain;\n\n    s.strstart = 0;\n    s.block_start = 0;\n    s.lookahead = 0;\n    s.insert = 0;\n    s.match_length = s.prev_length = MIN_MATCH - 1;\n    s.match_available = 0;\n    s.ins_h = 0;\n  };\n\n\n  function DeflateState() {\n    this.strm = null;            /* pointer back to this zlib stream */\n    this.status = 0;            /* as the name implies */\n    this.pending_buf = null;      /* output still pending */\n    this.pending_buf_size = 0;  /* size of pending_buf */\n    this.pending_out = 0;       /* next pending byte to output to the stream */\n    this.pending = 0;           /* nb of bytes in the pending buffer */\n    this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n    this.gzhead = null;         /* gzip header information to write */\n    this.gzindex = 0;           /* where in extra, name, or comment */\n    this.method = Z_DEFLATED$1; /* can only be DEFLATED */\n    this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n    this.w_size = 0;  /* LZ77 window size (32K by default) */\n    this.w_bits = 0;  /* log2(w_size)  (8..16) */\n    this.w_mask = 0;  /* w_size - 1 */\n\n    this.window = null;\n    /* Sliding window. Input bytes are read into the second half of the window,\n     * and move to the first half later to keep a dictionary of at least wSize\n     * bytes. With this organization, matches are limited to a distance of\n     * wSize-MAX_MATCH bytes, but this ensures that IO is always\n     * performed with a length multiple of the block size.\n     */\n\n    this.window_size = 0;\n    /* Actual size of window: 2*wSize, except when the user input buffer\n     * is directly used as sliding window.\n     */\n\n    this.prev = null;\n    /* Link to older string with same hash index. To limit the size of this\n     * array to 64K, this link is maintained only for the last 32K strings.\n     * An index in this array is thus a window index modulo 32K.\n     */\n\n    this.head = null;   /* Heads of the hash chains or NIL. */\n\n    this.ins_h = 0;       /* hash index of string to be inserted */\n    this.hash_size = 0;   /* number of elements in hash table */\n    this.hash_bits = 0;   /* log2(hash_size) */\n    this.hash_mask = 0;   /* hash_size-1 */\n\n    this.hash_shift = 0;\n    /* Number of bits by which ins_h must be shifted at each input\n     * step. It must be such that after MIN_MATCH steps, the oldest\n     * byte no longer takes part in the hash key, that is:\n     *   hash_shift * MIN_MATCH >= hash_bits\n     */\n\n    this.block_start = 0;\n    /* Window position at the beginning of the current output block. Gets\n     * negative when the window is moved backwards.\n     */\n\n    this.match_length = 0;      /* length of best match */\n    this.prev_match = 0;        /* previous match */\n    this.match_available = 0;   /* set if previous match exists */\n    this.strstart = 0;          /* start of string to insert */\n    this.match_start = 0;       /* start of matching string */\n    this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n    this.prev_length = 0;\n    /* Length of the best match at previous step. Matches not greater than this\n     * are discarded. This is used in the lazy match evaluation.\n     */\n\n    this.max_chain_length = 0;\n    /* To speed up deflation, hash chains are never searched beyond this\n     * length.  A higher limit improves compression ratio but degrades the\n     * speed.\n     */\n\n    this.max_lazy_match = 0;\n    /* Attempt to find a better match only when the current match is strictly\n     * smaller than this value. This mechanism is used only for compression\n     * levels >= 4.\n     */\n    // That's alias to max_lazy_match, don't use directly\n    //this.max_insert_length = 0;\n    /* Insert new strings in the hash table only if the match length is not\n     * greater than this length. This saves time but degrades compression.\n     * max_insert_length is used only for compression levels <= 3.\n     */\n\n    this.level = 0;     /* compression level (1..9) */\n    this.strategy = 0;  /* favor or force Huffman coding*/\n\n    this.good_match = 0;\n    /* Use a faster search when the previous match is longer than this */\n\n    this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n                /* used by trees.c: */\n\n    /* Didn't use ct_data typedef below to suppress compiler warning */\n\n    // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n    // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n    // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n    // Use flat array of DOUBLE size, with interleaved fata,\n    // because JS does not support effective\n    this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);\n    this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);\n    this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);\n    zero(this.dyn_ltree);\n    zero(this.dyn_dtree);\n    zero(this.bl_tree);\n\n    this.l_desc   = null;         /* desc. for literal tree */\n    this.d_desc   = null;         /* desc. for distance tree */\n    this.bl_desc  = null;         /* desc. for bit length tree */\n\n    //ush bl_count[MAX_BITS+1];\n    this.bl_count = new Uint16Array(MAX_BITS + 1);\n    /* number of codes at each bit length for an optimal tree */\n\n    //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n    this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n    zero(this.heap);\n\n    this.heap_len = 0;               /* number of elements in the heap */\n    this.heap_max = 0;               /* element of largest frequency */\n    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n     * The same heap array is used to build all trees.\n     */\n\n    this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n    zero(this.depth);\n    /* Depth of each subtree used as tie breaker for trees of equal frequency\n     */\n\n    this.l_buf = 0;          /* buffer index for literals or lengths */\n\n    this.lit_bufsize = 0;\n    /* Size of match buffer for literals/lengths.  There are 4 reasons for\n     * limiting lit_bufsize to 64K:\n     *   - frequencies can be kept in 16 bit counters\n     *   - if compression is not successful for the first block, all input\n     *     data is still in the window so we can still emit a stored block even\n     *     when input comes from standard input.  (This can also be done for\n     *     all blocks if lit_bufsize is not greater than 32K.)\n     *   - if compression is not successful for a file smaller than 64K, we can\n     *     even emit a stored file instead of a stored block (saving 5 bytes).\n     *     This is applicable only for zip (not gzip or zlib).\n     *   - creating new Huffman trees less frequently may not provide fast\n     *     adaptation to changes in the input data statistics. (Take for\n     *     example a binary file with poorly compressible code followed by\n     *     a highly compressible string table.) Smaller buffer sizes give\n     *     fast adaptation but have of course the overhead of transmitting\n     *     trees more frequently.\n     *   - I can't count above 4\n     */\n\n    this.last_lit = 0;      /* running index in l_buf */\n\n    this.d_buf = 0;\n    /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n     * the same number of elements. To use different lengths, an extra flag\n     * array would be necessary.\n     */\n\n    this.opt_len = 0;       /* bit length of current block with optimal trees */\n    this.static_len = 0;    /* bit length of current block with static trees */\n    this.matches = 0;       /* number of string matches in current block */\n    this.insert = 0;        /* bytes at end of window left to insert */\n\n\n    this.bi_buf = 0;\n    /* Output buffer. bits are inserted starting at the bottom (least\n     * significant bits).\n     */\n    this.bi_valid = 0;\n    /* Number of valid bits in bi_buf.  All bits above the last valid bit\n     * are always zero.\n     */\n\n    // Used for window memory init. We safely ignore it for JS. That makes\n    // sense only for pointers and memory check tools.\n    //this.high_water = 0;\n    /* High water mark offset in window for initialized bytes -- bytes above\n     * this are set to zero in order to avoid memory check warnings when\n     * longest match routines access bytes past the input.  This is then\n     * updated to the new high water mark.\n     */\n  }\n\n\n  const deflateResetKeep = (strm) => {\n\n    if (!strm || !strm.state) {\n      return err(strm, Z_STREAM_ERROR);\n    }\n\n    strm.total_in = strm.total_out = 0;\n    strm.data_type = Z_UNKNOWN;\n\n    const s = strm.state;\n    s.pending = 0;\n    s.pending_out = 0;\n\n    if (s.wrap < 0) {\n      s.wrap = -s.wrap;\n      /* was made negative by deflate(..., Z_FINISH); */\n    }\n    s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n    strm.adler = (s.wrap === 2) ?\n      0  // crc32(0, Z_NULL, 0)\n    :\n      1; // adler32(0, Z_NULL, 0)\n    s.last_flush = Z_NO_FLUSH$1;\n    _tr_init(s);\n    return Z_OK$1;\n  };\n\n\n  const deflateReset = (strm) => {\n\n    const ret = deflateResetKeep(strm);\n    if (ret === Z_OK$1) {\n      lm_init(strm.state);\n    }\n    return ret;\n  };\n\n\n  const deflateSetHeader = (strm, head) => {\n\n    if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n    if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n    strm.state.gzhead = head;\n    return Z_OK$1;\n  };\n\n\n  const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {\n\n    if (!strm) { // === Z_NULL\n      return Z_STREAM_ERROR;\n    }\n    let wrap = 1;\n\n    if (level === Z_DEFAULT_COMPRESSION$1) {\n      level = 6;\n    }\n\n    if (windowBits < 0) { /* suppress zlib wrapper */\n      wrap = 0;\n      windowBits = -windowBits;\n    }\n\n    else if (windowBits > 15) {\n      wrap = 2;           /* write gzip wrapper instead */\n      windowBits -= 16;\n    }\n\n\n    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$1 ||\n      windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n      strategy < 0 || strategy > Z_FIXED) {\n      return err(strm, Z_STREAM_ERROR);\n    }\n\n\n    if (windowBits === 8) {\n      windowBits = 9;\n    }\n    /* until 256-byte window bug fixed */\n\n    const s = new DeflateState();\n\n    strm.state = s;\n    s.strm = strm;\n\n    s.wrap = wrap;\n    s.gzhead = null;\n    s.w_bits = windowBits;\n    s.w_size = 1 << s.w_bits;\n    s.w_mask = s.w_size - 1;\n\n    s.hash_bits = memLevel + 7;\n    s.hash_size = 1 << s.hash_bits;\n    s.hash_mask = s.hash_size - 1;\n    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n    s.window = new Uint8Array(s.w_size * 2);\n    s.head = new Uint16Array(s.hash_size);\n    s.prev = new Uint16Array(s.w_size);\n\n    // Don't need mem init magic for JS.\n    //s.high_water = 0;  /* nothing written to s->window yet */\n\n    s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n    s.pending_buf_size = s.lit_bufsize * 4;\n\n    //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n    //s->pending_buf = (uchf *) overlay;\n    s.pending_buf = new Uint8Array(s.pending_buf_size);\n\n    // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n    //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n    s.d_buf = 1 * s.lit_bufsize;\n\n    //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n    s.l_buf = (1 + 2) * s.lit_bufsize;\n\n    s.level = level;\n    s.strategy = strategy;\n    s.method = method;\n\n    return deflateReset(strm);\n  };\n\n  const deflateInit = (strm, level) => {\n\n    return deflateInit2(strm, level, Z_DEFLATED$1, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);\n  };\n\n\n  const deflate$1 = (strm, flush) => {\n\n    let beg, val; // for gzip header write only\n\n    if (!strm || !strm.state ||\n      flush > Z_BLOCK || flush < 0) {\n      return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n    }\n\n    const s = strm.state;\n\n    if (!strm.output ||\n        (!strm.input && strm.avail_in !== 0) ||\n        (s.status === FINISH_STATE && flush !== Z_FINISH$1)) {\n      return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n    }\n\n    s.strm = strm; /* just in case */\n    const old_flush = s.last_flush;\n    s.last_flush = flush;\n\n    /* Write the header */\n    if (s.status === INIT_STATE) {\n\n      if (s.wrap === 2) { // GZIP header\n        strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n        put_byte(s, 31);\n        put_byte(s, 139);\n        put_byte(s, 8);\n        if (!s.gzhead) { // s->gzhead == Z_NULL\n          put_byte(s, 0);\n          put_byte(s, 0);\n          put_byte(s, 0);\n          put_byte(s, 0);\n          put_byte(s, 0);\n          put_byte(s, s.level === 9 ? 2 :\n                      (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                       4 : 0));\n          put_byte(s, OS_CODE);\n          s.status = BUSY_STATE;\n        }\n        else {\n          put_byte(s, (s.gzhead.text ? 1 : 0) +\n                      (s.gzhead.hcrc ? 2 : 0) +\n                      (!s.gzhead.extra ? 0 : 4) +\n                      (!s.gzhead.name ? 0 : 8) +\n                      (!s.gzhead.comment ? 0 : 16)\n          );\n          put_byte(s, s.gzhead.time & 0xff);\n          put_byte(s, (s.gzhead.time >> 8) & 0xff);\n          put_byte(s, (s.gzhead.time >> 16) & 0xff);\n          put_byte(s, (s.gzhead.time >> 24) & 0xff);\n          put_byte(s, s.level === 9 ? 2 :\n                      (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                       4 : 0));\n          put_byte(s, s.gzhead.os & 0xff);\n          if (s.gzhead.extra && s.gzhead.extra.length) {\n            put_byte(s, s.gzhead.extra.length & 0xff);\n            put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n          }\n          if (s.gzhead.hcrc) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);\n          }\n          s.gzindex = 0;\n          s.status = EXTRA_STATE;\n        }\n      }\n      else // DEFLATE header\n      {\n        let header = (Z_DEFLATED$1 + ((s.w_bits - 8) << 4)) << 8;\n        let level_flags = -1;\n\n        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n          level_flags = 0;\n        } else if (s.level < 6) {\n          level_flags = 1;\n        } else if (s.level === 6) {\n          level_flags = 2;\n        } else {\n          level_flags = 3;\n        }\n        header |= (level_flags << 6);\n        if (s.strstart !== 0) { header |= PRESET_DICT; }\n        header += 31 - (header % 31);\n\n        s.status = BUSY_STATE;\n        putShortMSB(s, header);\n\n        /* Save the adler32 of the preset dictionary: */\n        if (s.strstart !== 0) {\n          putShortMSB(s, strm.adler >>> 16);\n          putShortMSB(s, strm.adler & 0xffff);\n        }\n        strm.adler = 1; // adler32(0L, Z_NULL, 0);\n      }\n    }\n\n  //#ifdef GZIP\n    if (s.status === EXTRA_STATE) {\n      if (s.gzhead.extra/* != Z_NULL*/) {\n        beg = s.pending;  /* start of bytes to update crc */\n\n        while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n          if (s.pending === s.pending_buf_size) {\n            if (s.gzhead.hcrc && s.pending > beg) {\n              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n            flush_pending(strm);\n            beg = s.pending;\n            if (s.pending === s.pending_buf_size) {\n              break;\n            }\n          }\n          put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n          s.gzindex++;\n        }\n        if (s.gzhead.hcrc && s.pending > beg) {\n          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n        }\n        if (s.gzindex === s.gzhead.extra.length) {\n          s.gzindex = 0;\n          s.status = NAME_STATE;\n        }\n      }\n      else {\n        s.status = NAME_STATE;\n      }\n    }\n    if (s.status === NAME_STATE) {\n      if (s.gzhead.name/* != Z_NULL*/) {\n        beg = s.pending;  /* start of bytes to update crc */\n        //int val;\n\n        do {\n          if (s.pending === s.pending_buf_size) {\n            if (s.gzhead.hcrc && s.pending > beg) {\n              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n            flush_pending(strm);\n            beg = s.pending;\n            if (s.pending === s.pending_buf_size) {\n              val = 1;\n              break;\n            }\n          }\n          // JS specific: little magic to add zero terminator to end of string\n          if (s.gzindex < s.gzhead.name.length) {\n            val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n          } else {\n            val = 0;\n          }\n          put_byte(s, val);\n        } while (val !== 0);\n\n        if (s.gzhead.hcrc && s.pending > beg) {\n          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n        }\n        if (val === 0) {\n          s.gzindex = 0;\n          s.status = COMMENT_STATE;\n        }\n      }\n      else {\n        s.status = COMMENT_STATE;\n      }\n    }\n    if (s.status === COMMENT_STATE) {\n      if (s.gzhead.comment/* != Z_NULL*/) {\n        beg = s.pending;  /* start of bytes to update crc */\n        //int val;\n\n        do {\n          if (s.pending === s.pending_buf_size) {\n            if (s.gzhead.hcrc && s.pending > beg) {\n              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n            flush_pending(strm);\n            beg = s.pending;\n            if (s.pending === s.pending_buf_size) {\n              val = 1;\n              break;\n            }\n          }\n          // JS specific: little magic to add zero terminator to end of string\n          if (s.gzindex < s.gzhead.comment.length) {\n            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n          } else {\n            val = 0;\n          }\n          put_byte(s, val);\n        } while (val !== 0);\n\n        if (s.gzhead.hcrc && s.pending > beg) {\n          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n        }\n        if (val === 0) {\n          s.status = HCRC_STATE;\n        }\n      }\n      else {\n        s.status = HCRC_STATE;\n      }\n    }\n    if (s.status === HCRC_STATE) {\n      if (s.gzhead.hcrc) {\n        if (s.pending + 2 > s.pending_buf_size) {\n          flush_pending(strm);\n        }\n        if (s.pending + 2 <= s.pending_buf_size) {\n          put_byte(s, strm.adler & 0xff);\n          put_byte(s, (strm.adler >> 8) & 0xff);\n          strm.adler = 0; //crc32(0L, Z_NULL, 0);\n          s.status = BUSY_STATE;\n        }\n      }\n      else {\n        s.status = BUSY_STATE;\n      }\n    }\n  //#endif\n\n    /* Flush as much pending output as possible */\n    if (s.pending !== 0) {\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        /* Since avail_out is 0, deflate will be called again with\n         * more output space, but possibly with both pending and\n         * avail_in equal to zero. There won't be anything to do,\n         * but this is not an error situation so make sure we\n         * return OK instead of BUF_ERROR at next call of deflate:\n         */\n        s.last_flush = -1;\n        return Z_OK$1;\n      }\n\n      /* Make sure there is something to do and avoid duplicate consecutive\n       * flushes. For repeated and useless calls with Z_FINISH, we keep\n       * returning Z_STREAM_END instead of Z_BUF_ERROR.\n       */\n    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n      flush !== Z_FINISH$1) {\n      return err(strm, Z_BUF_ERROR);\n    }\n\n    /* User must not provide more input after the first FINISH: */\n    if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n      return err(strm, Z_BUF_ERROR);\n    }\n\n    /* Start a new block or continue the current one.\n     */\n    if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n      (flush !== Z_NO_FLUSH$1 && s.status !== FINISH_STATE)) {\n      let bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n        (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n          configuration_table[s.level].func(s, flush));\n\n      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n        s.status = FINISH_STATE;\n      }\n      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n        if (strm.avail_out === 0) {\n          s.last_flush = -1;\n          /* avoid BUF_ERROR next call, see above */\n        }\n        return Z_OK$1;\n        /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n         * of deflate should use the same flush parameter to make sure\n         * that the flush is complete. So we don't have to output an\n         * empty block here, this will be done at next call. This also\n         * ensures that for a very small output buffer, we emit at most\n         * one empty block.\n         */\n      }\n      if (bstate === BS_BLOCK_DONE) {\n        if (flush === Z_PARTIAL_FLUSH) {\n          _tr_align(s);\n        }\n        else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n          _tr_stored_block(s, 0, 0, false);\n          /* For a full flush, this empty block will be recognized\n           * as a special marker by inflate_sync().\n           */\n          if (flush === Z_FULL_FLUSH$1) {\n            /*** CLEAR_HASH(s); ***/             /* forget history */\n            zero(s.head); // Fill with NIL (= 0);\n\n            if (s.lookahead === 0) {\n              s.strstart = 0;\n              s.block_start = 0;\n              s.insert = 0;\n            }\n          }\n        }\n        flush_pending(strm);\n        if (strm.avail_out === 0) {\n          s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n          return Z_OK$1;\n        }\n      }\n    }\n    //Assert(strm->avail_out > 0, \"bug2\");\n    //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n    if (flush !== Z_FINISH$1) { return Z_OK$1; }\n    if (s.wrap <= 0) { return Z_STREAM_END$1; }\n\n    /* Write the trailer */\n    if (s.wrap === 2) {\n      put_byte(s, strm.adler & 0xff);\n      put_byte(s, (strm.adler >> 8) & 0xff);\n      put_byte(s, (strm.adler >> 16) & 0xff);\n      put_byte(s, (strm.adler >> 24) & 0xff);\n      put_byte(s, strm.total_in & 0xff);\n      put_byte(s, (strm.total_in >> 8) & 0xff);\n      put_byte(s, (strm.total_in >> 16) & 0xff);\n      put_byte(s, (strm.total_in >> 24) & 0xff);\n    }\n    else\n    {\n      putShortMSB(s, strm.adler >>> 16);\n      putShortMSB(s, strm.adler & 0xffff);\n    }\n\n    flush_pending(strm);\n    /* If avail_out is zero, the application will call deflate again\n     * to flush the rest.\n     */\n    if (s.wrap > 0) { s.wrap = -s.wrap; }\n    /* write the trailer only once! */\n    return s.pending !== 0 ? Z_OK$1 : Z_STREAM_END$1;\n  };\n\n\n  const deflateEnd = (strm) => {\n\n    if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n      return Z_STREAM_ERROR;\n    }\n\n    const status = strm.state.status;\n    if (status !== INIT_STATE &&\n      status !== EXTRA_STATE &&\n      status !== NAME_STATE &&\n      status !== COMMENT_STATE &&\n      status !== HCRC_STATE &&\n      status !== BUSY_STATE &&\n      status !== FINISH_STATE\n    ) {\n      return err(strm, Z_STREAM_ERROR);\n    }\n\n    strm.state = null;\n\n    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK$1;\n  };\n\n\n  /* =========================================================================\n   * Initializes the compression dictionary from the given byte\n   * sequence without producing any compressed output.\n   */\n  const deflateSetDictionary = (strm, dictionary) => {\n\n    let dictLength = dictionary.length;\n\n    if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n      return Z_STREAM_ERROR;\n    }\n\n    const s = strm.state;\n    const wrap = s.wrap;\n\n    if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n      return Z_STREAM_ERROR;\n    }\n\n    /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n    if (wrap === 1) {\n      /* adler32(strm->adler, dictionary, dictLength); */\n      strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);\n    }\n\n    s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n    /* if dictionary would fill window, just replace the history */\n    if (dictLength >= s.w_size) {\n      if (wrap === 0) {            /* already empty otherwise */\n        /*** CLEAR_HASH(s); ***/\n        zero(s.head); // Fill with NIL (= 0);\n        s.strstart = 0;\n        s.block_start = 0;\n        s.insert = 0;\n      }\n      /* use the tail */\n      // dictionary = dictionary.slice(dictLength - s.w_size);\n      let tmpDict = new Uint8Array(s.w_size);\n      tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);\n      dictionary = tmpDict;\n      dictLength = s.w_size;\n    }\n    /* insert dictionary into window and hash */\n    const avail = strm.avail_in;\n    const next = strm.next_in;\n    const input = strm.input;\n    strm.avail_in = dictLength;\n    strm.next_in = 0;\n    strm.input = dictionary;\n    fill_window(s);\n    while (s.lookahead >= MIN_MATCH) {\n      let str = s.strstart;\n      let n = s.lookahead - (MIN_MATCH - 1);\n      do {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n        s.head[s.ins_h] = str;\n        str++;\n      } while (--n);\n      s.strstart = str;\n      s.lookahead = MIN_MATCH - 1;\n      fill_window(s);\n    }\n    s.strstart += s.lookahead;\n    s.block_start = s.strstart;\n    s.insert = s.lookahead;\n    s.lookahead = 0;\n    s.match_length = s.prev_length = MIN_MATCH - 1;\n    s.match_available = 0;\n    strm.next_in = next;\n    strm.input = input;\n    strm.avail_in = avail;\n    s.wrap = wrap;\n    return Z_OK$1;\n  };\n\n\n  var deflateInit_1 = deflateInit;\n  var deflateInit2_1 = deflateInit2;\n  var deflateReset_1 = deflateReset;\n  var deflateResetKeep_1 = deflateResetKeep;\n  var deflateSetHeader_1 = deflateSetHeader;\n  var deflate_2$1 = deflate$1;\n  var deflateEnd_1 = deflateEnd;\n  var deflateSetDictionary_1 = deflateSetDictionary;\n  var deflateInfo = 'pako deflate (from Nodeca project)';\n\n  /* Not implemented\n  module.exports.deflateBound = deflateBound;\n  module.exports.deflateCopy = deflateCopy;\n  module.exports.deflateParams = deflateParams;\n  module.exports.deflatePending = deflatePending;\n  module.exports.deflatePrime = deflatePrime;\n  module.exports.deflateTune = deflateTune;\n  */\n\n  var deflate_1$1 = {\n  \tdeflateInit: deflateInit_1,\n  \tdeflateInit2: deflateInit2_1,\n  \tdeflateReset: deflateReset_1,\n  \tdeflateResetKeep: deflateResetKeep_1,\n  \tdeflateSetHeader: deflateSetHeader_1,\n  \tdeflate: deflate_2$1,\n  \tdeflateEnd: deflateEnd_1,\n  \tdeflateSetDictionary: deflateSetDictionary_1,\n  \tdeflateInfo: deflateInfo\n  };\n\n  const _has = (obj, key) => {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n  };\n\n  var assign = function (obj /*from1, from2, from3, ...*/) {\n    const sources = Array.prototype.slice.call(arguments, 1);\n    while (sources.length) {\n      const source = sources.shift();\n      if (!source) { continue; }\n\n      if (typeof source !== 'object') {\n        throw new TypeError(source + 'must be non-object');\n      }\n\n      for (const p in source) {\n        if (_has(source, p)) {\n          obj[p] = source[p];\n        }\n      }\n    }\n\n    return obj;\n  };\n\n\n  // Join array of chunks to single array.\n  var flattenChunks = (chunks) => {\n    // calculate data length\n    let len = 0;\n\n    for (let i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    const result = new Uint8Array(len);\n\n    for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {\n      let chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  };\n\n  var common = {\n  \tassign: assign,\n  \tflattenChunks: flattenChunks\n  };\n\n  // String encode/decode helpers\n\n\n  // Quick check if we can use fast array to bin string conversion\n  //\n  // - apply(Array) can fail on Android 2.2\n  // - apply(Uint8Array) can fail on iOS 5.1 Safari\n  //\n  let STR_APPLY_UIA_OK = true;\n\n  try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n  // Table with utf8 lengths (calculated by first byte of sequence)\n  // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n  // because max possible codepoint is 0x10ffff\n  const _utf8len = new Uint8Array(256);\n  for (let q = 0; q < 256; q++) {\n    _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n  }\n  _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n  // convert string to array (typed, when possible)\n  var string2buf = (str) => {\n    if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {\n      return new TextEncoder().encode(str);\n    }\n\n    let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n    // count binary size\n    for (m_pos = 0; m_pos < str_len; m_pos++) {\n      c = str.charCodeAt(m_pos);\n      if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n        c2 = str.charCodeAt(m_pos + 1);\n        if ((c2 & 0xfc00) === 0xdc00) {\n          c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n          m_pos++;\n        }\n      }\n      buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n    }\n\n    // allocate buffer\n    buf = new Uint8Array(buf_len);\n\n    // convert\n    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n      c = str.charCodeAt(m_pos);\n      if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n        c2 = str.charCodeAt(m_pos + 1);\n        if ((c2 & 0xfc00) === 0xdc00) {\n          c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n          m_pos++;\n        }\n      }\n      if (c < 0x80) {\n        /* one byte */\n        buf[i++] = c;\n      } else if (c < 0x800) {\n        /* two bytes */\n        buf[i++] = 0xC0 | (c >>> 6);\n        buf[i++] = 0x80 | (c & 0x3f);\n      } else if (c < 0x10000) {\n        /* three bytes */\n        buf[i++] = 0xE0 | (c >>> 12);\n        buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n        buf[i++] = 0x80 | (c & 0x3f);\n      } else {\n        /* four bytes */\n        buf[i++] = 0xf0 | (c >>> 18);\n        buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n        buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n        buf[i++] = 0x80 | (c & 0x3f);\n      }\n    }\n\n    return buf;\n  };\n\n  // Helper\n  const buf2binstring = (buf, len) => {\n    // On Chrome, the arguments in a function call that are allowed is `65534`.\n    // If the length of the buffer is smaller than that, we can use this optimization,\n    // otherwise we will take a slower path.\n    if (len < 65534) {\n      if (buf.subarray && STR_APPLY_UIA_OK) {\n        return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));\n      }\n    }\n\n    let result = '';\n    for (let i = 0; i < len; i++) {\n      result += String.fromCharCode(buf[i]);\n    }\n    return result;\n  };\n\n\n  // convert array to string\n  var buf2string = (buf, max) => {\n    const len = max || buf.length;\n\n    if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {\n      return new TextDecoder().decode(buf.subarray(0, max));\n    }\n\n    let i, out;\n\n    // Reserve max possible length (2 words per char)\n    // NB: by unknown reasons, Array is significantly faster for\n    //     String.fromCharCode.apply than Uint16Array.\n    const utf16buf = new Array(len * 2);\n\n    for (out = 0, i = 0; i < len;) {\n      let c = buf[i++];\n      // quick process ascii\n      if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n      let c_len = _utf8len[c];\n      // skip 5 & 6 byte codes\n      if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n      // apply mask on first byte\n      c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n      // join the rest\n      while (c_len > 1 && i < len) {\n        c = (c << 6) | (buf[i++] & 0x3f);\n        c_len--;\n      }\n\n      // terminated by end of string?\n      if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n      if (c < 0x10000) {\n        utf16buf[out++] = c;\n      } else {\n        c -= 0x10000;\n        utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n        utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n      }\n    }\n\n    return buf2binstring(utf16buf, out);\n  };\n\n\n  // Calculate max possible position in utf8 buffer,\n  // that will not break sequence. If that's not possible\n  // - (very small limits) return max size as is.\n  //\n  // buf[] - utf8 bytes array\n  // max   - length limit (mandatory);\n  var utf8border = (buf, max) => {\n\n    max = max || buf.length;\n    if (max > buf.length) { max = buf.length; }\n\n    // go back from last position, until start of sequence found\n    let pos = max - 1;\n    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n    // Very small and broken sequence,\n    // return max, because we should return something anyway.\n    if (pos < 0) { return max; }\n\n    // If we came to start of buffer - that means buffer is too small,\n    // return max too.\n    if (pos === 0) { return max; }\n\n    return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n  };\n\n  var strings = {\n  \tstring2buf: string2buf,\n  \tbuf2string: buf2string,\n  \tutf8border: utf8border\n  };\n\n  // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n  //\n  // This software is provided 'as-is', without any express or implied\n  // warranty. In no event will the authors be held liable for any damages\n  // arising from the use of this software.\n  //\n  // Permission is granted to anyone to use this software for any purpose,\n  // including commercial applications, and to alter it and redistribute it\n  // freely, subject to the following restrictions:\n  //\n  // 1. The origin of this software must not be misrepresented; you must not\n  //   claim that you wrote the original software. If you use this software\n  //   in a product, an acknowledgment in the product documentation would be\n  //   appreciated but is not required.\n  // 2. Altered source versions must be plainly marked as such, and must not be\n  //   misrepresented as being the original software.\n  // 3. This notice may not be removed or altered from any source distribution.\n\n  function ZStream() {\n    /* next input byte */\n    this.input = null; // JS specific, because we have no pointers\n    this.next_in = 0;\n    /* number of bytes available at input */\n    this.avail_in = 0;\n    /* total number of input bytes read so far */\n    this.total_in = 0;\n    /* next output byte should be put there */\n    this.output = null; // JS specific, because we have no pointers\n    this.next_out = 0;\n    /* remaining free space at output */\n    this.avail_out = 0;\n    /* total number of bytes output so far */\n    this.total_out = 0;\n    /* last error message, NULL if no error */\n    this.msg = ''/*Z_NULL*/;\n    /* not visible by applications */\n    this.state = null;\n    /* best guess about the data type: binary or text */\n    this.data_type = 2/*Z_UNKNOWN*/;\n    /* adler32 value of the uncompressed data */\n    this.adler = 0;\n  }\n\n  var zstream = ZStream;\n\n  const toString = Object.prototype.toString;\n\n  /* Public constants ==========================================================*/\n  /* ===========================================================================*/\n\n  const {\n    Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH,\n    Z_OK, Z_STREAM_END,\n    Z_DEFAULT_COMPRESSION,\n    Z_DEFAULT_STRATEGY,\n    Z_DEFLATED\n  } = constants$1;\n\n  /* ===========================================================================*/\n\n\n  /**\n   * class Deflate\n   *\n   * Generic JS-style wrapper for zlib calls. If you don't need\n   * streaming behaviour - use more simple functions: [[deflate]],\n   * [[deflateRaw]] and [[gzip]].\n   **/\n\n  /* internal\n   * Deflate.chunks -> Array\n   *\n   * Chunks of output data, if [[Deflate#onData]] not overridden.\n   **/\n\n  /**\n   * Deflate.result -> Uint8Array\n   *\n   * Compressed result, generated by default [[Deflate#onData]]\n   * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n   * (call [[Deflate#push]] with `Z_FINISH` / `true` param).\n   **/\n\n  /**\n   * Deflate.err -> Number\n   *\n   * Error code after deflate finished. 0 (Z_OK) on success.\n   * You will not need it in real life, because deflate errors\n   * are possible only on wrong options or bad `onData` / `onEnd`\n   * custom handlers.\n   **/\n\n  /**\n   * Deflate.msg -> String\n   *\n   * Error message, if [[Deflate.err]] != 0\n   **/\n\n\n  /**\n   * new Deflate(options)\n   * - options (Object): zlib deflate options.\n   *\n   * Creates new deflator instance with specified params. Throws exception\n   * on bad params. Supported options:\n   *\n   * - `level`\n   * - `windowBits`\n   * - `memLevel`\n   * - `strategy`\n   * - `dictionary`\n   *\n   * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n   * for more information on these.\n   *\n   * Additional options, for internal needs:\n   *\n   * - `chunkSize` - size of generated data chunks (16K by default)\n   * - `raw` (Boolean) - do raw deflate\n   * - `gzip` (Boolean) - create gzip wrapper\n   * - `header` (Object) - custom header for gzip\n   *   - `text` (Boolean) - true if compressed data believed to be text\n   *   - `time` (Number) - modification time, unix timestamp\n   *   - `os` (Number) - operation system code\n   *   - `extra` (Array) - array of bytes with extra data (max 65536)\n   *   - `name` (String) - file name (binary string)\n   *   - `comment` (String) - comment (binary string)\n   *   - `hcrc` (Boolean) - true if header crc should be added\n   *\n   * ##### Example:\n   *\n   * ```javascript\n   * const pako = require('pako')\n   *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n   *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n   *\n   * const deflate = new pako.Deflate({ level: 3});\n   *\n   * deflate.push(chunk1, false);\n   * deflate.push(chunk2, true);  // true -> last chunk\n   *\n   * if (deflate.err) { throw new Error(deflate.err); }\n   *\n   * console.log(deflate.result);\n   * ```\n   **/\n  function Deflate(options) {\n    this.options = common.assign({\n      level: Z_DEFAULT_COMPRESSION,\n      method: Z_DEFLATED,\n      chunkSize: 16384,\n      windowBits: 15,\n      memLevel: 8,\n      strategy: Z_DEFAULT_STRATEGY\n    }, options || {});\n\n    let opt = this.options;\n\n    if (opt.raw && (opt.windowBits > 0)) {\n      opt.windowBits = -opt.windowBits;\n    }\n\n    else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n      opt.windowBits += 16;\n    }\n\n    this.err    = 0;      // error code, if happens (0 = Z_OK)\n    this.msg    = '';     // error message\n    this.ended  = false;  // used to avoid multiple onEnd() calls\n    this.chunks = [];     // chunks of compressed data\n\n    this.strm = new zstream();\n    this.strm.avail_out = 0;\n\n    let status = deflate_1$1.deflateInit2(\n      this.strm,\n      opt.level,\n      opt.method,\n      opt.windowBits,\n      opt.memLevel,\n      opt.strategy\n    );\n\n    if (status !== Z_OK) {\n      throw new Error(messages[status]);\n    }\n\n    if (opt.header) {\n      deflate_1$1.deflateSetHeader(this.strm, opt.header);\n    }\n\n    if (opt.dictionary) {\n      let dict;\n      // Convert data if needed\n      if (typeof opt.dictionary === 'string') {\n        // If we need to compress text, change encoding to utf8.\n        dict = strings.string2buf(opt.dictionary);\n      } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n        dict = new Uint8Array(opt.dictionary);\n      } else {\n        dict = opt.dictionary;\n      }\n\n      status = deflate_1$1.deflateSetDictionary(this.strm, dict);\n\n      if (status !== Z_OK) {\n        throw new Error(messages[status]);\n      }\n\n      this._dict_set = true;\n    }\n  }\n\n  /**\n   * Deflate#push(data[, flush_mode]) -> Boolean\n   * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be\n   *   converted to utf8 byte sequence.\n   * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n   *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n   *\n   * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n   * new compressed chunks. Returns `true` on success. The last data block must\n   * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending\n   * buffers and call [[Deflate#onEnd]].\n   *\n   * On fail call [[Deflate#onEnd]] with error code and return false.\n   *\n   * ##### Example\n   *\n   * ```javascript\n   * push(chunk, false); // push one of data chunks\n   * ...\n   * push(chunk, true);  // push last chunk\n   * ```\n   **/\n  Deflate.prototype.push = function (data, flush_mode) {\n    const strm = this.strm;\n    const chunkSize = this.options.chunkSize;\n    let status, _flush_mode;\n\n    if (this.ended) { return false; }\n\n    if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;\n    else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;\n\n    // Convert data if needed\n    if (typeof data === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      strm.input = strings.string2buf(data);\n    } else if (toString.call(data) === '[object ArrayBuffer]') {\n      strm.input = new Uint8Array(data);\n    } else {\n      strm.input = data;\n    }\n\n    strm.next_in = 0;\n    strm.avail_in = strm.input.length;\n\n    for (;;) {\n      if (strm.avail_out === 0) {\n        strm.output = new Uint8Array(chunkSize);\n        strm.next_out = 0;\n        strm.avail_out = chunkSize;\n      }\n\n      // Make sure avail_out > 6 to avoid repeating markers\n      if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {\n        this.onData(strm.output.subarray(0, strm.next_out));\n        strm.avail_out = 0;\n        continue;\n      }\n\n      status = deflate_1$1.deflate(strm, _flush_mode);\n\n      // Ended => flush and finish\n      if (status === Z_STREAM_END) {\n        if (strm.next_out > 0) {\n          this.onData(strm.output.subarray(0, strm.next_out));\n        }\n        status = deflate_1$1.deflateEnd(this.strm);\n        this.onEnd(status);\n        this.ended = true;\n        return status === Z_OK;\n      }\n\n      // Flush if out buffer full\n      if (strm.avail_out === 0) {\n        this.onData(strm.output);\n        continue;\n      }\n\n      // Flush if requested and has data\n      if (_flush_mode > 0 && strm.next_out > 0) {\n        this.onData(strm.output.subarray(0, strm.next_out));\n        strm.avail_out = 0;\n        continue;\n      }\n\n      if (strm.avail_in === 0) break;\n    }\n\n    return true;\n  };\n\n\n  /**\n   * Deflate#onData(chunk) -> Void\n   * - chunk (Uint8Array): output data.\n   *\n   * By default, stores data blocks in `chunks[]` property and glue\n   * those in `onEnd`. Override this handler, if you need another behaviour.\n   **/\n  Deflate.prototype.onData = function (chunk) {\n    this.chunks.push(chunk);\n  };\n\n\n  /**\n   * Deflate#onEnd(status) -> Void\n   * - status (Number): deflate status. 0 (Z_OK) on success,\n   *   other if not.\n   *\n   * Called once after you tell deflate that the input stream is\n   * complete (Z_FINISH). By default - join collected chunks,\n   * free memory and fill `results` / `err` properties.\n   **/\n  Deflate.prototype.onEnd = function (status) {\n    // On success - join\n    if (status === Z_OK) {\n      this.result = common.flattenChunks(this.chunks);\n    }\n    this.chunks = [];\n    this.err = status;\n    this.msg = this.strm.msg;\n  };\n\n\n  /**\n   * deflate(data[, options]) -> Uint8Array\n   * - data (Uint8Array|String): input data to compress.\n   * - options (Object): zlib deflate options.\n   *\n   * Compress `data` with deflate algorithm and `options`.\n   *\n   * Supported options are:\n   *\n   * - level\n   * - windowBits\n   * - memLevel\n   * - strategy\n   * - dictionary\n   *\n   * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n   * for more information on these.\n   *\n   * Sugar (options):\n   *\n   * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n   *   negative windowBits implicitly.\n   *\n   * ##### Example:\n   *\n   * ```javascript\n   * const pako = require('pako')\n   * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);\n   *\n   * console.log(pako.deflate(data));\n   * ```\n   **/\n  function deflate(input, options) {\n    const deflator = new Deflate(options);\n\n    deflator.push(input, true);\n\n    // That will never happens, if you don't cheat with options :)\n    if (deflator.err) { throw deflator.msg || messages[deflator.err]; }\n\n    return deflator.result;\n  }\n\n\n  /**\n   * deflateRaw(data[, options]) -> Uint8Array\n   * - data (Uint8Array|String): input data to compress.\n   * - options (Object): zlib deflate options.\n   *\n   * The same as [[deflate]], but creates raw data, without wrapper\n   * (header and adler32 crc).\n   **/\n  function deflateRaw(input, options) {\n    options = options || {};\n    options.raw = true;\n    return deflate(input, options);\n  }\n\n\n  /**\n   * gzip(data[, options]) -> Uint8Array\n   * - data (Uint8Array|String): input data to compress.\n   * - options (Object): zlib deflate options.\n   *\n   * The same as [[deflate]], but create gzip wrapper instead of\n   * deflate one.\n   **/\n  function gzip(input, options) {\n    options = options || {};\n    options.gzip = true;\n    return deflate(input, options);\n  }\n\n\n  var Deflate_1 = Deflate;\n  var deflate_2 = deflate;\n  var deflateRaw_1 = deflateRaw;\n  var gzip_1 = gzip;\n  var constants = constants$1;\n\n  var deflate_1 = {\n  \tDeflate: Deflate_1,\n  \tdeflate: deflate_2,\n  \tdeflateRaw: deflateRaw_1,\n  \tgzip: gzip_1,\n  \tconstants: constants\n  };\n\n  exports.Deflate = Deflate_1;\n  exports.constants = constants;\n  exports['default'] = deflate_1;\n  exports.deflate = deflate_2;\n  exports.deflateRaw = deflateRaw_1;\n  exports.gzip = gzip_1;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","import { gzip } from 'pako/dist/pako_deflate.js';\n\nself.onmessage = (event) => {\n  try {\n    const result = gzip(event.data.data).buffer;\n    self.postMessage({\n      id: event.data.id,\n      result,\n    });\n  } catch (error) {\n    self.postMessage({\n      id: event.data.id,\n      error: error.message,\n    });\n  }\n};\n"],"names":["exports","zero$1","buf","len","length","LITERALS$1","L_CODES$1","D_CODES$1","MAX_BITS$1","extra_lbits","Uint8Array","extra_dbits","extra_blbits","bl_order","static_ltree","Array","static_dtree","_dist_code","_length_code","MAX_MATCH$1","base_length","base_dist","StaticTreeDesc","static_tree","extra_bits","extra_base","elems","max_length","this","has_stree","static_l_desc","static_d_desc","static_bl_desc","TreeDesc","dyn_tree","stat_desc","max_code","d_code","dist","put_short","s","w","pending_buf","pending","send_bits","value","bi_valid","bi_buf","send_code","c","tree","bi_reverse","code","res","gen_codes","bl_count","next_code","bits","n","init_block","dyn_ltree","dyn_dtree","bl_tree","END_BLOCK","opt_len","static_len","last_lit","matches","bi_windup","smaller","m","depth","_n2","_m2","pqdownheap","k","v","heap","j","heap_len","compress_block","ltree","dtree","lc","extra","lx","d_buf","l_buf","build_tree","desc","stree","node","heap_max","base","h","xbits","f","overflow","gen_bitlen","scan_tree","curlen","prevlen","nextlen","count","max_count","min_count","REP_3_6","REPZ_3_10","REPZ_11_138","send_tree","static_init_done","_tr_stored_block$1","stored_len","last","header","set","window","subarray","copy_block","trees","_tr_init","LENGTH_CODES$1","tr_static_init","l_desc","d_desc","bl_desc","_tr_stored_block","_tr_flush_block","opt_lenb","static_lenb","max_blindex","level","strm","data_type","black_mask","detect_data_type","BL_CODES$1","build_bl_tree","strategy","lcodes","dcodes","blcodes","rank","send_all_trees","_tr_tally","lit_bufsize","_tr_align","STATIC_TREES","bi_flush","adler32_1","adler","pos","s1","s2","crcTable","Uint32Array","table","makeTable","crc32_1","crc","t","end","i","messages","constants$1","Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_SYNC_FLUSH","Z_FULL_FLUSH","Z_FINISH","Z_BLOCK","Z_TREES","Z_OK","Z_STREAM_END","Z_NEED_DICT","Z_ERRNO","Z_STREAM_ERROR","Z_DATA_ERROR","Z_MEM_ERROR","Z_BUF_ERROR","Z_NO_COMPRESSION","Z_BEST_SPEED","Z_BEST_COMPRESSION","Z_DEFAULT_COMPRESSION","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_FIXED","Z_DEFAULT_STRATEGY","Z_BINARY","Z_TEXT","Z_UNKNOWN","Z_DEFLATED","Z_NO_FLUSH$1","Z_FULL_FLUSH$1","Z_FINISH$1","Z_OK$1","Z_STREAM_END$1","Z_DEFAULT_COMPRESSION$1","Z_DEFAULT_STRATEGY$1","Z_DEFLATED$1","MAX_MATCH","MIN_LOOKAHEAD","HCRC_STATE","BUSY_STATE","FINISH_STATE","err","errorCode","msg","zero","HASH","prev","data","hash_shift","hash_mask","flush_pending","state","avail_out","output","pending_out","next_out","total_out","flush_block_only","block_start","strstart","put_byte","b","putShortMSB","read_buf","start","size","avail_in","input","next_in","wrap","total_in","longest_match","cur_match","match","chain_length","max_chain_length","scan","best_len","prev_length","nice_match","limit","w_size","_win","wmask","w_mask","strend","scan_end1","scan_end","good_match","lookahead","match_start","fill_window","_w_size","p","more","str","window_size","hash_size","head","insert","ins_h","deflate_fast","flush","hash_head","bflush","match_length","max_lazy_match","MIN_MATCH","deflate_slow","max_insert","prev_match","match_available","Config","good_length","max_lazy","nice_length","max_chain","func","configuration_table","max_block_size","pending_buf_size","max_start","DeflateState","status","gzhead","gzindex","method","last_flush","w_bits","hash_bits","Uint16Array","HEAP_SIZE","MAX_BITS","deflateResetKeep","deflateReset","ret","deflateInit2","windowBits","memLevel","deflate_1$1","deflateInit","deflateSetHeader","deflate","beg","val","old_flush","text","hcrc","name","comment","time","os","level_flags","charCodeAt","bstate","deflate_huff","deflate_rle","deflateEnd","deflateSetDictionary","dictionary","dictLength","tmpDict","avail","next","deflateInfo","_has","obj","key","Object","prototype","hasOwnProperty","call","common","assign","sources","slice","arguments","source","shift","TypeError","flattenChunks","chunks","l","result","chunk","STR_APPLY_UIA_OK","String","fromCharCode","apply","__","_utf8len","q","strings","string2buf","TextEncoder","encode","c2","m_pos","str_len","buf_len","buf2string","max","TextDecoder","decode","out","utf16buf","c_len","buf2binstring","utf8border","zstream","toString","Deflate","options","chunkSize","opt","raw","gzip","ended","Error","dict","_dict_set","deflator","push","flush_mode","_flush_mode","onData","onEnd","Deflate_1","deflate_2","deflateRaw_1","gzip_1","constants","deflate_1","deflateRaw","defineProperty","factory","self","onmessage","event","buffer","postMessage","id","error","message"],"mappings":"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"}